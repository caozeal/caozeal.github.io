<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>我的 AI Coding 工具选择与实践</title>
    <link href="/2026/02/12/AI/%E6%88%91%E7%9A%84%20AI%20Coding%20%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <url>/2026/02/12/AI/%E6%88%91%E7%9A%84%20AI%20Coding%20%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="我的-AI-Coding-工具选择与实践"><a href="#我的-AI-Coding-工具选择与实践" class="headerlink" title="我的 AI Coding 工具选择与实践"></a>我的 AI Coding 工具选择与实践</h1><p>站在现在这个时间点来看，AI Coding确实已经进入了白热化阶段。</p><p>从模型上来讲，国外三巨头Claude 、GPT、Gemini 频繁升级版本，且都对编码能力做了特化，国内deepseek稳中求变，豆包、千问也先后推出编码特化模型，GLM、Kimi、MiniMax争先拥抱以Claude Code为首的各种编码辅助工具。</p><p>从工具上来讲，Github Copilot率先布局，随后cursor一鸣惊人，Cline（含Roo Code, Kilo Code）系列插件广为人使用，随后的Claude Code仿佛杀死了比赛，独揽霸权，Kiro，Codex，Gemini Cli，Antigravity等先后推出，百花齐放。</p><p>一方面，Code Agent是通向AGI的一个核心阶段，万物互联，皆以程序驱动，编码赋予AI通向一切互联网可达之触手；另一方面，逐步脱离IDE的AI Code Agent形态降低了更多非编程从业人员的入门门槛，丰富的想象力、各行业清晰的洞察力、独树一帜的见解与敢于人先的尝试精神成为创造的核心能力，编码不再是拦路虎，一切皆有可能。</p><p><img src="/../../resources/ai-coding/Pasted%20image%2020260203161059.png" alt="AI Coding 工具发展时间线"></p><blockquote><p>图片源自网络</p></blockquote><h2 id="一、行业现状：码农的红利-or-末日？"><a href="#一、行业现状：码农的红利-or-末日？" class="headerlink" title="一、行业现状：码农的红利 or 末日？"></a>一、行业现状：码农的红利 or 末日？</h2><p>AI Coding工具早不是那个只能产出玩具代码的时代了，针对大模型AI Code 的测试也逐渐升级，从六边形弹球、三维世界模拟到鹈鹕骑自行车、天气卡片，各大厂的工具平台（包括Claude Code）都有着大量AI开发参与的痕迹，各式各样的非编程从业人员涌入了开发赛道，开发网站的专业性与美观确实让人佩服。部分实例如下：</p><p><a href="https://fast3d.io/">fast3d</a></p><p><img src="/../../resources/ai-coding/PixPin_2026-02-03_16-21-39.png" alt="Fast3D - AI 生成的 3D 建模工具"></p><p><a href="https://raphael.app/">raphael</a></p><p><img src="/../../resources/ai-coding/PixPin_2026-02-03_16-23-36%201.png" alt="Raphael - AI 生成的设计工具"></p><p>在AI的加持下，非程序员的研发能力迅速追上程序员”正规军”，基于个人对AI工具的使用能力，研发能力上限被无限拉高，甚至能超过大部分不会使用AI的开发。码农的红利 or 末日？时代确实变了。</p><h2 id="二、个人实践：多-Agent-协作工作流"><a href="#二、个人实践：多-Agent-协作工作流" class="headerlink" title="二、个人实践：多 Agent 协作工作流"></a>二、个人实践：多 Agent 协作工作流</h2><h3 id="2-1-工具链组合"><a href="#2-1-工具链组合" class="headerlink" title="2.1 工具链组合"></a>2.1 工具链组合</h3><p>受限于单一工具的使用成本，与各模型、工具能力差异，每个人对 AI 工具选择有着各自的喜好，我大部分时间都在开发后端代码，因此主要使用 Claude Code + Codex + Antigravity 配合开发，Kiro Code 生成提交代码与兜底。</p><p>整套的核心是 Claude Code（以下简称 CC），由 CC 进行需求分析与架构设计，掌控大局，由 Codex（仔细谨慎，以下简称 CX）进行具体的后端代码开发，Gemini（审美）进行前端页面设计（如有需要），Antigravity 则以其快速响应的优势，快速修改问题，进行局部调整优化。</p><h3 id="2-2-协作架构"><a href="#2-2-协作架构" class="headerlink" title="2.2 协作架构"></a>2.2 协作架构</h3><p><img src="/../../resources/ai-coding/PixPin_2026-02-03_16-42-00.png" alt="Claude Code 工作流程示意图"></p><p><img src="/../../resources/ai-coding/PixPin_2026-02-03_18-25-04.png" alt="多 Agent 协作架构图"></p><h3 id="2-3-安装与配置"><a href="#2-3-安装与配置" class="headerlink" title="2.3 安装与配置"></a>2.3 安装与配置</h3><p>CC 的安装可以参考：<a href="/html/ai/claude-code-install.html">cc 自定义 API 接入及安装指南</a></p><p>VSCode 及其衍生 IDE（cursor、antigravity、kiro、trae 等）直接通过扩展市场安装，然后参考上述修改配置文件即可。</p><h3 id="2-4-详细协作参考"><a href="#2-4-详细协作参考" class="headerlink" title="2.4 详细协作参考"></a>2.4 详细协作参考</h3><ul><li><a href="https://mp.weixin.qq.com/s/w-jv5FVU3puOqGRpJXvE5w">Claude Code 与 Codex 协作开发 3.0：从 MCP 到 Skills 的技术演进</a>（该公众号还有其他更好的协作与之后的演化，我感觉这个最适合我，感兴趣可以查看他的其他文章）</li></ul><h2 id="三、AI-Coding-技巧（以Claude-Code为例）"><a href="#三、AI-Coding-技巧（以Claude-Code为例）" class="headerlink" title="三、AI Coding 技巧（以Claude Code为例）"></a>三、AI Coding 技巧（以Claude Code为例）</h2><h3 id="3-1-基础信息"><a href="#3-1-基础信息" class="headerlink" title="3.1 基础信息"></a>3.1 基础信息</h3><p><strong>支持途径：</strong> Claude Code 套餐、API</p><p><strong>支持端：</strong> CLI、VSCode 插件、客户端（仅支持官方账号）</p><p><strong>模型选择：</strong></p><ul><li><strong>Haiku</strong>：快速模型，单价最低，速度最快，用于处理前期准备搜索工作</li><li><strong>Sonnet</strong>：常规模型，能力均衡，性价比高</li><li><strong>Opus</strong>：最强模型，价格最贵，4.5 版本迎来降价，由于更智能，能使用更快更少的步骤完成任务，变相降低消费，成为很多人的第一选择</li><li>也可通过 ClaudeCodeRouter、NewApi 等工具接入，或者办理 GLM、MiniMax、Kimi 等编程套餐来体验其他模型</li></ul><h3 id="3-2-核心特性"><a href="#3-2-核心特性" class="headerlink" title="3.2 核心特性"></a>3.2 核心特性</h3><ol><li><p><strong>三种工作模式</strong></p><p>Claude 有三个模式，Plan Mode、默认模式、accept edits，可以 Shift + Tab 切换，可以在配置文件中配置默认的模式，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;permissions&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;defaultMode&quot;</span>: <span class="hljs-string">&quot;plan&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>Plan Mode</strong>：计划模式，CC 不会修改代码，他会整体查找分析和用户需求相关的代码与文档，给出实现方案，该模式下常常会触发 <code>AskUserQuestion</code> 来询问用户，给出选择以补充策略。</li><li><strong>默认模式</strong>：此时会修改代码，修改时会征求用户同意</li><li><strong>Accept Edits</strong>：此时会修改代码，并且不征求用户同意，直接修改</li><li><strong>最佳实践</strong>：Explore first, then plan, then code - 这是 CC 官方推荐的最佳实践，先进入 Plan 模式，让 Claude 进行需求相关代码的探索，然后进行计划，此时我们要根据计划是否完善进行审查，若有偏离及时沟通纠正。当确认计划没问题后，选择同意计划并进入 accept edits，此时 CC 会按照计划来修改代码。</li><li>因此推荐添加上述配置，默认计划模式</li></ul></li><li><p><strong>上下文管理策略</strong></p><p>任何大模型都有最大窗口限制，Claude 也不例外，虽然 CC 有自动压缩机制，但是压缩后的上下文准确度大幅下降，过量的上下文对钱包也是一种灾难。因此一个窗口尽量只实现一个功能，也就是进行一次探索→计划→实现→测试，以开发需求为例，最佳实践为：</p><ul><li>与 CC 讨论整体需求架构，可以粘贴需求文档、原型截图等</li><li>确定整体架构后，拆分功能模块，按探索→计划→实现→测试的步骤逐步实现模块</li><li>若是实现一个模块之后发现与预期有偏差，偏差大了→直接回退代码，重开窗口重新设计实现，特别少的局部偏差→当前窗口内要求修改，处于上述两种情况中间→新开窗口，要求修改</li></ul></li><li><p><strong>斜杠命令（Slash Command）</strong></p><p>CC 有着很多的斜杠命令（slash command），可以自行探索</p></li><li><p><strong>MCP、Skills、SubAgent 机制</strong></p><p>Claude Code 有着完善的 MCP、skills、subAgent 机制：</p><ul><li><strong>MCP</strong>：每个 MCP 的 Token 占用相对较大，通常建议仅配置必须的 MCP，如：Context7、sequential-thinking 等</li><li><strong>Skills</strong>：近几个月流传出来的概念，可以看做是优化版的 MCP，采用了渐进式上下文的技术来优化上下文占用，可以在 CLAUDE.md 中指明什么时候使用什么技能，也可以在对话中明确要求。</li><li><strong>SubAgent</strong>：子代理，CC 会并行调用多个子代理来完成不同的任务，也可以自定义不同的个性化子代理</li><li>完全可以通过对话的方式直接添加，比如跟 CC 说”帮我安装一下 MCP：Context7”</li></ul></li><li><p><strong>CLI 灵活性与 Bash 模式</strong></p><p>CC CLI 比 CC 插件更灵活，可以在任意地方唤起，并且在 CC 中能够使用 <code>!</code> 来切换到 bash 模式</p><p><img src="/../../resources/ai-coding/PixPin_2026-02-04_09-21-48.png" alt="Claude Code CLI Bash 模式"></p></li><li><p><strong>多场景应用能力</strong></p><p>CC 除了编程、测试、排查问题外，你也可以让他执行很多其他事，比如：”合并代码到 develop 并推送”、”检查当前分支相对于 release 分支的变更”、”清理系统磁盘”等系统操作，甚至可以”查找 github 中最热门项目”等 web 操作查询。</p></li></ol><h3 id="3-3-使用技巧"><a href="#3-3-使用技巧" class="headerlink" title="3.3 使用技巧"></a>3.3 使用技巧</h3><ol><li><p><strong>配置优化（自定义 API 接入）</strong></p><p>自定义 API 接入的话，配置文件最好添加上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;env&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;ANTHROPIC_AUTH_TOKEN&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span>,<br>    <span class="hljs-string">&quot;ANTHROPIC_BASE_URL&quot;</span>: <span class="hljs-string">&quot;http://xxx&quot;</span>,<br>    <span class="hljs-string">&quot;CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>,<br>    <span class="hljs-string">&quot;DISABLE_TELEMETRY&quot;</span>: <span class="hljs-string">&quot;1&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>&quot;CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC&quot;: &quot;1&quot;</code>：禁用非必要流量</li><li><code>&quot;DISABLE_TELEMETRY&quot;: &quot;1&quot;</code>：禁用遥测</li><li>上述两个配置减少非必要的请求与 token 消耗</li></ul></li><li><p><strong>及时 Commit 避免代码丢失</strong></p><p>当你认可某次 AI 修改的内容，及时 commit，否则你很大几率会体验刚写好的代码被 AI 删除的灾难</p></li><li><p><strong>提前理解需求避免返工</strong></p><p>使用 AI 编程很重要的一个就是，需要提前理解透需求，在开发前，自己的理解，与 AI 讨论进行理解。千万要避免边开发边理解，AI 开发后的返工简直是灾难。</p></li></ol><p><strong>参考资料：</strong></p><ul><li><a href="https://code.claude.com/docs/en/overview">CC 官方文档</a></li></ul><h2 id="四、总结与展望"><a href="#四、总结与展望" class="headerlink" title="四、总结与展望"></a>四、总结与展望</h2><p>AI Coding 让更多的人能实现自我创意，编程不再是技术壁垒，重复性工作、样板代码生成、API 调用等场景效率也显著提升。</p><p>目前AI Coding也进入了高速发展的快车道，被裹挟在其中的我们何去何从，是每个人都要思考的课题。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>Claude Code</tag>
      
      <tag>Skills</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clickhouse清理简单总结</title>
    <link href="/2025/05/19/clickhouse%E6%B8%85%E7%90%86%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <url>/2025/05/19/clickhouse%E6%B8%85%E7%90%86%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="clickhouse清理简单总结"><a href="#clickhouse清理简单总结" class="headerlink" title="clickhouse清理简单总结"></a>clickhouse清理简单总结</h1><blockquote><p>背景：clickhouse磁盘占用过大，需要清理以腾出可用空间，对clickhouse不太熟悉，记录一下处理过程，以供参考</p></blockquote><ol><li>先查看哪些表占用空间最多：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    database,<br>    <span class="hljs-keyword">table</span>,<br>    formatReadableSize(<span class="hljs-built_in">sum</span>(bytes_on_disk)) <span class="hljs-keyword">AS</span> total_size<br><span class="hljs-keyword">FROM</span> system.parts<br><span class="hljs-keyword">WHERE</span> active<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> database, <span class="hljs-keyword">table</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">sum</span>(bytes_on_disk) <span class="hljs-keyword">DESC</span><br></code></pre></td></tr></table></figure><p><img src="/../resources/ck/clickhouse_1.png"></p><ol start="2"><li><p>查询结果如上，query_thread_log，query_log是 ClickHouse 的系统操作日志表，占用空间很大，基本可以判断是<strong>日志保留时间过长或配置异常</strong>导致的。</p></li><li><p>delete删除很慢，大表的情况下几乎不能使用，（保险些）不清除全表的情况下可以按分区清理。先确认下这个表是否有分区。</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> system.tables<br><span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;query_thread_log&#x27;</span> <span class="hljs-keyword">AND</span> database <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;system&#x27;</span>;<br></code></pre></td></tr></table></figure><p>建表结果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 省略</span><br>ENGINE <span class="hljs-operator">=</span> MergeTree<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> toYYYYMM(event_time)<br><span class="hljs-comment">-- 省略</span><br></code></pre></td></tr></table></figure><p>看出，确实按照event_time进行分区。</p><ol start="4"><li>我们可以先来清理历史分区</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> system.query_thread_log <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PARTITION</span> <span class="hljs-number">202312</span>;<br></code></pre></td></tr></table></figure><ol start="5"><li>使用sql查询已有分区也会卡住，可以查看目录文件确认有哪些分区</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$&#123;ck_home&#125;</span>/data/system/query_thread_log<br><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>可以看到如下目录（看起来一直没有清理过）：<br><img src="/../resources/ck/clickhouse_2.png"><br>6. 同样地，<code>query_log</code>也可以清理</p><ol start="7"><li><p>进一步，可以创建定时任务，来定时清理过期的日志文件，保持磁盘空间。</p></li><li><p>若确认近期的日志也不需要，则可以直接清空整张表</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 清空 query_log 表</span><br><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> system.query_log;<br><br><span class="hljs-comment">-- 清空 query_thread_log 表</span><br><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> system.query_thread_log;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>clickhouse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MCP漫游（二）：深入服务端</title>
    <link href="/2025/03/19/AI/MCP%E6%BC%AB%E6%B8%B8%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    <url>/2025/03/19/AI/MCP%E6%BC%AB%E6%B8%B8%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="MCP漫游（二）：深入服务端"><a href="#MCP漫游（二）：深入服务端" class="headerlink" title="MCP漫游（二）：深入服务端"></a>MCP漫游（二）：深入服务端</h1><ol><li><a href="../MCP%E6%BC%AB%E6%B8%B8.md">MCP漫游</a></li></ol><p> 上文对MCP有了个整体的理解，本文将深入探讨MCP Server, 并照着示例实现一个简单的MCP Server。</p><h2 id="一、初探MCP-Server"><a href="#一、初探MCP-Server" class="headerlink" title="一、初探MCP Server"></a>一、初探MCP Server</h2><p><img src="/../../resources/ai/MCP_architecture.png" alt="MCP通用架构"></p><blockquote><p>MCP Servers: Lightweight programs that each expose specific capabilities through the standardized Model Context Protocol</p></blockquote><blockquote><p><em>MCP 服务器：通过标准化的模型上下文协议暴露特定功能的轻量级程序</em><br>     – <a href="https://modelcontextprotocol.io/introduction#general-architecture">MCP官网</a></p></blockquote><h2 id="二、Goose"><a href="#二、Goose" class="headerlink" title="二、Goose"></a>二、Goose</h2><p>我们之前使用cursor演示了MCP的一些应用，但是cursor只有agent模式可以使用，每用一次都会消耗一次高级模型额度，claude desktop由于某些原因，使用难度更大。</p><p>那有没有其他更友好一些的MCP Client呢？有的。<a href="https://modelcontextprotocol.io/clients#feature-support-matrix">MCP Client功能支持矩阵</a>中列出了20多个客户端，其中很多客户端支持自定义LLM api，降低了MCP的使用门槛，可以根据自己熟悉的或喜欢的去体验。我们先来看一下Goose，然后基于Goose来体验MCP Server。</p><p><img src="/../../resources/ai/mcp2_client.png" alt="MCP Client功能支持矩阵"></p><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p><a href="https://block.github.io/goose/docs/quickstart">Goose</a> 是一个开源的人工智能助手，通过自动化编码任务来加速你的软件开发，macOS、Linux和Windows WSL都可以运行Goose CLI，macOS也支持桌面端Goose Desktop。</p><ul><li>安装Goose CLI</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://github.com/block/goose/releases/download/stable/download_cli.sh | bash<br></code></pre></td></tr></table></figure><p>或者</p><ul><li>安装Goose Desktop（macOS）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install --cask block-goose<br></code></pre></td></tr></table></figure><p>或者直接下载客户端：<a href="https://github.com/block/goose/releases/download/stable/Goose.zip">Goose Desktop macOS Sillcon</a></p><h3 id="2-配置大模型"><a href="#2-配置大模型" class="headerlink" title="2. 配置大模型"></a>2. 配置大模型</h3><p>以桌面版举例，安装好之后打开，我们就可以来配置自定义大模型。</p><p><img src="/../../resources/ai/mcp2_goose_config.png" alt="Goose Desktop配置大模型"></p><p>众所周知，大模型providers中没有自己期望的话，都可以往OpenAI中配置😶‍🌫️，我这里使用了<a href="https://bailian.console.aliyun.com/#/model-market">阿里云百炼</a>，配置如下：<br><img src="/../../resources/ai/mcp2_goose_openai.png" alt="Goose Desktop配置OpenAI"></p><p>百炼中支持的模型还是比较多的，而且大部分都有100万的免费token额度，还是比较良心的。</p><h3 id="3-选择模型"><a href="#3-选择模型" class="headerlink" title="3. 选择模型"></a>3. 选择模型</h3><p>配置好provider后，就可以选择模型了，不是所有的模型都支持MCP，需要模型具有Function Calling能力，<a href="https://gorilla.cs.berkeley.edu/leaderboard.html">伯克利函数调用排行榜</a>中可以作为我们选择模型的参考，通义千问中支持Function Calling的模型可以参考：<a href="https://help.aliyun.com/zh/model-studio/user-guide/qwen-function-calling">通义千问Function Calling</a>。这里我使用了<code>qwen-plus</code>。</p><h3 id="4-管理Extensions（即MCP-Server）"><a href="#4-管理Extensions（即MCP-Server）" class="headerlink" title="4. 管理Extensions（即MCP Server）"></a>4. 管理Extensions（即MCP Server）</h3><p>Goose Desktop中提供了Extensions管理功能，可以方便地管理。<code>Settings -&gt; Extensions</code>中我们可以看到已经启用了几个默认的插件， 点击<code>Broswe</code>可以浏览更多。</p><p><img src="/../../resources/ai/mcp2_goose_extension.png" alt="Goose Desktop Extensions"></p><h3 id="5-使用"><a href="#5-使用" class="headerlink" title="5. 使用"></a>5. 使用</h3><p>我们照例，问一句：“你会做什么？”</p><p><img src="/../../resources/ai/mcp2_goose_start.png" alt="Goose Desktop 使用"></p><p>嗯，听起来会的还挺多。</p><ul><li>搜索最近关于人工智能突破的近期新闻，并总结关键发现</li></ul><p><img src="/../../resources/ai/mcp2_goose_search.png" alt="Goose Desktop 搜索新闻"></p><p>成功搜索并总结关键发现，顺便夸了一下中国。</p><p>接下来，我们尝试按照示例编写一个简单的MCP Server，并通过Goose Desktop来体验它。</p><h2 id="三、让大鹅飞"><a href="#三、让大鹅飞" class="headerlink" title="三、让大鹅飞"></a>三、让大鹅飞</h2><p>官网示例地址：<a href="https://modelcontextprotocol.io/quickstart/server">https://modelcontextprotocol.io/quickstart/server</a></p><p>MCP Server可以提供三种主要类型的功能：Resources、Tools、Prompts。这次我们跟着教程开发一个Tools – 一个简单的获取天气的MCP Server。</p><p>教程里可以选择Python, Node, Java，这里我们选择Python。</p><h3 id="1-准备环境"><a href="#1-准备环境" class="headerlink" title="1. 准备环境"></a>1. 准备环境</h3><p>首先是安装uv，我们上文已经安装了uv，这里就不再赘述了。然后初始化项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv init weather<br><span class="hljs-built_in">cd</span> weather<br><br><span class="hljs-comment"># 创建虚拟环境并激活</span><br>uv venv<br><span class="hljs-built_in">source</span> .venv/bin/activate<br><br><span class="hljs-comment"># 安装依赖</span><br>uv add <span class="hljs-string">&quot;mcp[cli]&quot;</span> httpx<br><br><span class="hljs-comment"># 创建server文件</span><br><span class="hljs-built_in">touch</span> weather.py<br></code></pre></td></tr></table></figure><h3 id="2-实现MCP-Server"><a href="#2-实现MCP-Server" class="headerlink" title="2. 实现MCP Server"></a>2. 实现MCP Server</h3><p>实现代码就不一一赘述，按照官网示例中编写即可，可以看到几个关键点：</p><ul><li>初始化了一个FastMCP server</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Initialize FastMCP server</span><br>mcp = FastMCP(<span class="hljs-string">&quot;weather&quot;</span>)<br><br></code></pre></td></tr></table></figure><ul><li>定义了该server具体的工具：<code>get_weather</code>和<code>get_weather_forecast</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Define tools</span><br><span class="hljs-meta">@mcp.tool</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_forecast</span>(<span class="hljs-params">latitude: <span class="hljs-built_in">float</span>, longitude: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;Get weather forecast for a location.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        latitude: Latitude of the location</span><br><span class="hljs-string">        longitude: Longitude of the location</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment">#实际处理数据</span><br>    <span class="hljs-comment">#返回prompt给大模型分析</span><br></code></pre></td></tr></table></figure><h3 id="3-工作流程"><a href="#3-工作流程" class="headerlink" title="3. 工作流程"></a>3. 工作流程</h3><p>当你发送了一个问题，MCP实际做了这些：</p><ol><li>客户端将你的问题和可能使用的工具发送给大模型</li><li>大模型分析你的问题，并决定使用哪个工具</li><li>客户端通过 MCP 服务器执行所选的工具（或工具集）</li><li>执行结果被发送回大模型</li><li>大模型获取结果后，整理总结返回</li></ol><p><img src="/../../resources/ai/mcp2_goose_flow.png" alt="MCP Server工作流程"></p><h3 id="4-体验"><a href="#4-体验" class="headerlink" title="4. 体验"></a>4. 体验</h3><p>我们将我们的MCP Server添加到Goose Desktop中，选择<code>Add Custom Extension</code>，依次添加配置即可。Command填写<code>uv --directory /ParentFolder/weather run weather.py</code>即可</p><p><img src="/../../resources/ai/mcp2_goose_custom.png" alt="Goose Desktop Extensions"></p><p>让我们来试一下：</p><ul><li>北京的天气怎么样？</li></ul><p><img src="/../../resources/ai/mcp2_goose_weather.png" alt="Goose Desktop 使用"></p><p>代码中调用的是（<a href="https://api.weather.gov/">https://api.weather.gov</a> – 美国国家气象局）的API，看来无法查询北京，不过可以看到，大模型成功选择并调用Tool，北京被成功解析成了经纬度。让我们来试试纽约</p><ul><li>纽约的天气怎么样？</li></ul><p><img src="/../../resources/ai/mcp2_goose_weather2.png" alt="Goose Desktop 使用"></p><p>哈，这次成功了，并按照要求返回了纽约的天气预报，这次Goose完全可以扮演我们的穿衣建议助手了。</p><p><img src="/../../resources/ai/mcp2_goose_weather3.png" alt="Goose Desktop 使用"></p><h2 id="四、最后"><a href="#四、最后" class="headerlink" title="四、最后"></a>四、最后</h2><p>通过这次体验，我们发现MCP Server的实现并不复杂，只需要定义好工具，并实现具体的处理逻辑即可。Goose Desktop的体验也非常不错，可以方便地管理Extensions，并提供了丰富的功能。大家感兴趣的话强烈建议尝试一下。</p><p>（不过话说回来， 带上工具后的请求，消耗的token也是如流水一般，三句简单的提问，干出了10万+的token，体验的时候一定要多多注意自己的账单~）</p><h2 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h2><ul><li><a href="https://modelcontextprotocol.io/quickstart/server">MCP官网</a></li><li><a href="https://block.github.io/goose/docs/quickstart">Goose</a></li><li><a href="https://gorilla.cs.berkeley.edu/leaderboard.html">伯克利函数调用排行榜</a></li><li><a href="https://help.aliyun.com/zh/model-studio/user-guide/qwen-function-calling">通义千问Function Calling</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MCP</tag>
      
      <tag>AI</tag>
      
      <tag>Protocol</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MCP漫游</title>
    <link href="/2025/03/07/AI/MCP%E6%BC%AB%E6%B8%B8/"/>
    <url>/2025/03/07/AI/MCP%E6%BC%AB%E6%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="MCP漫游"><a href="#MCP漫游" class="headerlink" title="MCP漫游"></a>MCP漫游</h1><blockquote><p>本文涉及关键词：AI, MCP, Claude, python, cursor</p></blockquote><blockquote><p>Model Context Protocol (MCP) 是一个开放协议，它实现了AI应用与外部数据源之间的无缝集成。由Anthropic开源，其核心目标是标准化AI系统获取上下文的方式，使AI助手能够更好地访问和利用各类数据源。</p></blockquote><h2 id="一、从AIGC说起"><a href="#一、从AIGC说起" class="headerlink" title="一、从AIGC说起"></a>一、从AIGC说起</h2><p>AIGC（Artificial Intelligence Generated Content, AI生成内容）指的是利用人工智能技术自动生成文本、图像、音频、视频等内容，这是AI技术在创意领域的重要应用。如gpt系列、claude、deepseek等大型语言模型，dall-e、midjourney、stable diffusion等图像生成模型，以及suno、jukedeck等音乐生成AI等。经过了最近这几年的飞速发展，AIGC技术已经切实改变了我们的生活和工作方式。</p><p>纯粹的AIGC技术，可以是一位老师，可以是一枚网友，可以是一本翻译书，也可以是一位创作者，我们畅所欲言地与之交谈，不用担心被嘲笑问题的无知，也不会被嫌弃喋喋不休的探讨。</p><p>在经过一段时间的热切使用后，新鲜感退去，我们不禁思考，对话框之外，我们能用他(她)做什么？他（她）们是否能够不仅仅是“张嘴说话”，而是进一步，去“动手做事”？解析完excel后的数据是否可以不用复制粘贴到数据库或报告中，生成的命令是否可以直接运行，翻译后的文本自动替换到原文档中，生成的音乐是否可以直接上传到音乐平台，生成的图像是不是能够自动配上文案并发布到朋友圈？AI是否能做到这最后一步，乃至将他（她）的思想无限扩展，在整个互联网中<br>蔓延，做到万物互联的核心？答案是，当然可以，我们也确实是在向这个方向发展，MCP就是这么一个协议，将AI与外部工具连接，扩展AI边界。用MCP官网的话来说，“可以把 MCP 想象成 AI 应用的 USB-C 端口。就像 USB-C 为设备连接各种外围设备和配件提供了标准化的方式一样，MCP 为 AI 模型连接不同的数据源和工具提供了标准化的方式。”</p><blockquote><p>MCP is an open protocol that standardizes how applications provide context to LLMs. Think of MCP like a USB-C port for AI applications. Just as USB-C provides a standardized way to connect your devices to various peripherals and accessories, MCP provides a standardized way to connect AI models to different data sources and tools.</p></blockquote><blockquote><p><em>MCP 是一个开放协议，标准化了应用程序如何向LLMs提供模型上下文。可以把 MCP 想象成 AI 应用的 USB-C 端口。就像 USB-C 为设备连接各种外围设备和配件提供了标准化的方式一样，MCP 为 AI 模型连接不同的数据源和工具提供了标准化的方式。</em></p></blockquote><blockquote><p>– MCP官网(<a href="https://modelcontextprotocol.io/introduction">https://modelcontextprotocol.io/introduction</a>)</p></blockquote><h2 id="二、MCP概览"><a href="#二、MCP概览" class="headerlink" title="二、MCP概览"></a>二、MCP概览</h2><p>MCP是一种开放标准，使开发人员能够建立他们数据源和人工智能驱动工具之间的安全双向连接。该架构很简单：开发人员可以通过 MCP 服务器公开他们的数据，或者构建连接到这些服务器的人工智能应用程序（MCP 客户端）。</p><h3 id="MCP通用架构"><a href="#MCP通用架构" class="headerlink" title="MCP通用架构"></a>MCP通用架构</h3><p><img src="/../../resources/ai/MCP_architecture.png" alt="MCP通用架构"></p><p>MCP定义了三个主要角色：</p><ol><li>Host: 发起连接的LLM应用，比如Claude Desktop, cursor等</li><li>Client: Host应用中的连接器，与服务器保持 1:1 连接</li><li>Server: 通过标准化的MCP暴露特定功能的轻量级程序</li></ol><p>host通过client连接到server，大模型决策当前会话需要执行哪个serer的哪个命令，server负责处理数据的获取和处理。其中，client 与server之间的通信是通过MCP协议进行的。<br>目前server仅支持本地服务，更像是一个插件，即插即用。</p><h3 id="MCP试用"><a href="#MCP试用" class="headerlink" title="MCP试用"></a>MCP试用</h3><p>下面以cursor为例，引入sqlite数据库，展示MCP的工作流程。<br>其中：</p><ul><li>Host: cursor</li><li>Client: cursor-mcp</li><li>Server: sqlite mcp server</li></ul><p>sqlite mcp server的具体配置可以参考[sqlite-mcp-server](<a href="https://github.com/modelcontextprotocol/servers/tree/HEAD/src/sqlite%EF%BC%89">https://github.com/modelcontextprotocol/servers/tree/HEAD/src/sqlite）</a></p><h4 id="1-第一步打开cursor-settings，选择MCP选项，点击“Add-Server”添加一个新的MCP服务器"><a href="#1-第一步打开cursor-settings，选择MCP选项，点击“Add-Server”添加一个新的MCP服务器" class="headerlink" title="1. 第一步打开cursor settings，选择MCP选项，点击“Add Server”添加一个新的MCP服务器"></a>1. 第一步打开cursor settings，选择MCP选项，点击“Add Server”添加一个新的MCP服务器</h4><p><img src="/../../resources/ai/mcp_cursor_settings.png" alt="cursor settings"></p><h4 id="2-选择command，按照提示输入相关信息，点击“Add-Command”添加一个新的命令，如下图所示"><a href="#2-选择command，按照提示输入相关信息，点击“Add-Command”添加一个新的命令，如下图所示" class="headerlink" title="2. 选择command，按照提示输入相关信息，点击“Add Command”添加一个新的命令，如下图所示"></a>2. 选择command，按照提示输入相关信息，点击“Add Command”添加一个新的命令，如下图所示</h4><p><img src="/../../resources/ai/mcp_cursor_sqlite.png" alt="cursor command"></p><ul><li>uvx &#x3D; uv tool run的缩写，表示运行uv工具，uv是一个Python包和项目管理器，这里代表这个MCP server是采用python实现的。（我们需要提前准备python环境，和安装uv）</li><li>[sqlite-mcp-server](<a href="https://github.com/modelcontextprotocol/servers/tree/HEAD/src/sqlite%EF%BC%89%E4%B8%AD%E4%BB%8B%E7%BB%8D%E4%BA%86claude">https://github.com/modelcontextprotocol/servers/tree/HEAD/src/sqlite）中介绍了claude</a> desktop的配置方法，这里我们将其转化为cursor的配置即可：<code>uvx mcp-server-sqlite --db-path ~/test.db</code>， 或者在项目下<code>./.cursor/mcp.json</code>中按照claude desktop的配置方法配置：</li></ul><p>claude desktop的配置方法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># <span class="hljs-keyword">Add</span> the <span class="hljs-keyword">server</span> <span class="hljs-keyword">to</span> your claude_desktop_config.json<br>&quot;mcpServers&quot;: &#123;<br>  &quot;sqlite&quot;: &#123;<br>    &quot;command&quot;: &quot;uv&quot;,<br>    &quot;args&quot;: [<br>      &quot;--directory&quot;,<br>      &quot;parent_of_servers_repo/servers/src/sqlite&quot;,<br>      &quot;run&quot;,<br>      &quot;mcp-server-sqlite&quot;,<br>      &quot;--db-path&quot;,<br>      &quot;~/test.db&quot;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-配置好之后，我们看到cursor的MCP服务器列表中已经添加了sqlite，并且成功获取到了server的一些信息。这时我们的cursor-agent已经可以通过MCP协议来查询操作我们指定的sqlite数据库了。"><a href="#3-配置好之后，我们看到cursor的MCP服务器列表中已经添加了sqlite，并且成功获取到了server的一些信息。这时我们的cursor-agent已经可以通过MCP协议来查询操作我们指定的sqlite数据库了。" class="headerlink" title="3. 配置好之后，我们看到cursor的MCP服务器列表中已经添加了sqlite，并且成功获取到了server的一些信息。这时我们的cursor agent已经可以通过MCP协议来查询操作我们指定的sqlite数据库了。"></a>3. 配置好之后，我们看到cursor的MCP服务器列表中已经添加了sqlite，并且成功获取到了server的一些信息。这时我们的cursor agent已经可以通过MCP协议来查询操作我们指定的sqlite数据库了。</h4><p><img src="/../../resources/ai/mcp_cursor_sqlite_server.png" alt="cursor mcp server"></p><h4 id="4-数据库中我已经提前初始化了一些数据，现在我们可以通过agent来操作这些数据。"><a href="#4-数据库中我已经提前初始化了一些数据，现在我们可以通过agent来操作这些数据。" class="headerlink" title="4. 数据库中我已经提前初始化了一些数据，现在我们可以通过agent来操作这些数据。"></a>4. 数据库中我已经提前初始化了一些数据，现在我们可以通过agent来操作这些数据。</h4><ul><li>User: 查找sqlite中的模型信息，并进行分类统计</li><li>Agent:</li></ul><p><img src="/../../resources/ai/mcp_cursor_demo.png" alt="cursor mcp demo"></p><p>从图中可以看到，cursor agent通过MCP协议成功连接到了sqlite server，并且成功查询并进行了分析。同样地，我们添加filesystem-server，并让AI操作文件</p><ul><li>User: 找出你认为性价比最高的五个模型，并导出为csv格式保存到桌面上</li><li>Agent:</li></ul><p><img src="/../../resources/ai/mcp_cursor_save.png" alt="cursor mcp demo"></p><p>此时打开桌面，已经生成了一个csv文件，并自动命名成了“top_cost_effective_models.csv”,打开文件，成功导出了五条数据，并在最后一列主动加入了理由。</p><p><img src="/../../resources/ai/mcp_cursor_save1.png" alt="cursor mcp demo"></p><h2 id="三、离AGI还有多远"><a href="#三、离AGI还有多远" class="headerlink" title="三、离AGI还有多远"></a>三、离AGI还有多远</h2><p>目前MCP还处于早期阶段，AI的边界还有待进一步拓展，上述的例子也只是不多（目前大约1500+）的MCP Server中的一粟，其他的server还有很多，比如浏览网页、请求接口、模拟用户行为浏览操作网页、读取google drive数据、查改mysql等数据库、git操作等等，我们可以利用这些server赋能大模型，扩展其边界，未来户发展到哪一步，还有多久能迈向AGI，我们拭目以待。</p><p>这两天，所谓首个通用AI Agent - Manus刷屏，试看了主页的几个例子，也都很流畅，从提出需求，到沟通、设计、编写，到最后的成果，确实令人神往，相信今后AI确实能做到这个程度，随着AI推理逻辑能力的提升，以后只会越来越顺畅。但现在，Manus是否能稳定做到演示中的那样，还是只是一场吸引眼球的秀，不妨让子弹飞一会。</p><h2 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h2><ol><li><a href="https://www.anthropic.com/news/model-context-protocol">Introducing the Model Context Protocol:  https://www.anthropic.com/news/model-context-protocol</a></li><li><a href="https://modelcontextprotocol.io/introduction">Model Context Protocol:  https://modelcontextprotocol.io/introduction</a></li><li><a href="https://github.com/modelcontextprotocol/servers">MCP Servers git仓库:  https://github.com/modelcontextprotocol/servers</a></li><li><a href="https://docs.cursor.com/context/model-context-protocol">cursor网站介绍MCP:  https://docs.cursor.com/context/model-context-protocol</a></li><li><a href="https://www.pulsemcp.com/servers">pulse - MCP Servers收集:  https://www.pulsemcp.com/servers</a></li><li><a href="https://www.axtonliu.ai/newsletters/ai-2/posts/claude-mcp-protocol-guide">一文详解 Claude 开源黑科技 MCP ｜ AI 精英周刊 012:  https://www.axtonliu.ai/newsletters/ai-2/posts/claude-mcp-protocol-guide</a></li><li><a href="https://manus.im/">Manus官网:  https://manus.im/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MCP</tag>
      
      <tag>AI</tag>
      
      <tag>Protocol</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《个人博客部署以及域名配置》</title>
    <link href="/2024/02/28/%E5%8D%9A%E5%AE%A2/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%8F%8A%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/02/28/%E5%8D%9A%E5%AE%A2/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%8F%8A%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="个人博客部署以及域名配置"><a href="#个人博客部署以及域名配置" class="headerlink" title="个人博客部署以及域名配置"></a>个人博客部署以及域名配置</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>博客挺久之前就弄了，不过写的文章比较少。最初是用的github pages，github pages的访问速度在国内不是很理想，时常会出现访问不了的情况。后面脑袋一抽，买了个域名，然后接触到了cloudflare，就把域名解析到了cloudflare，使用cloudflare的cdn加速，访问速度有了一些提升。找了几个朋友测试，反馈第一次访问速度还是有点慢，后面会好一些。<br>最近在github上看到了chat-gpt-next-web，使用了vercel，所以就折腾了下，也用vercel部署了博客，然后通过cloudflare，现在国内访问速度还是可以的。这篇文章主要是记录一下博客的部署过程，以及域名的配置过程。</p><h2 id="二、vercel"><a href="#二、vercel" class="headerlink" title="二、vercel"></a>二、vercel</h2><blockquote><p>Vercel is a platform for developers that provides the tools, workflows, and infrastructure you need to build and deploy your web apps faster, without the need for additional configuration.</p></blockquote><blockquote><p>Vercel 是一个为开发者提供工具、工作流和基础设施的平台，可以让你更快地构建和部署你的 Web 应用，而无需额外的配置。</p></blockquote><p>vercel官网：<a href="https://vercel.com/">https://vercel.com/</a>，可以直接使用github账号登录。</p><h3 id="1-部署"><a href="#1-部署" class="headerlink" title="1. 部署"></a>1. 部署</h3><p>因为之前已经有了github pages，所以我们可以直接通过vercel部署。Add New -&gt; Project -&gt; 选择自己的git repository -&gt; Import<br>自动识别出了Hexo, 都采用默认配置，然后Deploy。不出意外的话，出了意外，部署失败了。想到hexo 的deploy branch默认是gh-pages，vercel部署了master分支，所以我们需要修改一下。在vercel的项目中，Settings -&gt; Git -&gt; Production Branch -&gt; gh-pages -&gt; Save。</p><p><img src="/../../resources/blog/vercel_brach.png" alt="vercel branch设置"></p><p>回头重新部署，却发现部署的还是master，这时注意到<code>Production Brach</code>下有一行字</p><blockquote><p>By default, every commit pushed to the main branch will trigger a Production Deployment instead of the usual Preview Deployment. You can switch to a different branch here.</p></blockquote><blockquote><p>默认情况下，每次推送到主分支的提交都会触发生产部署，而不是通常的预览部署。您可以在这里切换到不同的分支。</p></blockquote><p>生产分支的部署可以通过推送到主分支来触发，二话不说，直接推送到主分支，这时候多出了两条Deployment记录，一条是Preview Deployment，一条是Production Deployment。Production Deployment即是使用了gh-pages分支。</p><p>这时候的错误变成了<code>sh: hexo: command not found</code><br>gp-pages分支通过github的action生成，已经普通的前端静态资源了，无需再使用hexo预设框架，修改Settings -&gt; Build &amp; Development Settings -&gt; Framework Preset 为Other, 重新部署成功。</p><p><img src="/../../resources/blog/vercel_success.png" alt="成功访问"></p><blockquote><p>注：我主要是为了同时能使用github pages和vercel，所以使用了gh-pages，如果只是使用vercel，完全可以新建github repository，直接使用master分支。</p></blockquote><h3 id="2-优化"><a href="#2-优化" class="headerlink" title="2. 优化"></a>2. 优化</h3><h4 id="a-域名配置"><a href="#a-域名配置" class="headerlink" title="a. 域名配置"></a>a. 域名配置</h4><p>vercel部署成功后，会有一个网址，（中国大陆地区用户）直接访问这个地址的话，会发现访问不通的情况，这是因为vercel部署的服务都被dns污染了，所以我们管理域名的dns记录，将域名解析到vercel。Settings -&gt; Domains  -&gt; 输入域名 -&gt; Add, 我之前操作过了，这里使用test域名。<br><img src="/../../resources/blog/vercel_domain.png" alt="vercel域名设置"></p><p>添加成功后，会有一个CNAME记录，将这个记录添加到域名的dns记录中，这里使用cloudflare，添加CNAME记录，Content填写<code>cname.vercel-dns.com</code>，保存后发现仍然无法访问，那看来<code>cname.vercel-dns.com</code>这个地址不能直接使用，搜索网络发现，中国大陆地区用户可以使用<code>cname-china.vercel-dns.com</code>，修改CNAME记录，保存。<br><img src="/../../resources/blog/cloudflare_cname.png" alt="cloudflare cname设置"></p><h4 id="b-重定向"><a href="#b-重定向" class="headerlink" title="b. 重定向"></a>b. 重定向</h4><p>配置好后，访问报了重定向次数过多的问题，这是因为cloudflare的ssl配置问题，需要将cloudflare的ssl配置为<code>Full</code>或者<code>Full(strict)</code>，这里使用<code>Full</code>，保存后，访问成功。<br><img src="/../../resources/blog/cloudflare_ssl.png" alt="cloudflare ssl设置"></p><p><img src="/../../resources/blog/blog.png" alt="博客"></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>这篇文章记录了下博客的部署过程，以及域名的配置过程，主要是使用了github pages，vercel，cloudflare。测试了一下，国内访问速度还是可以的，后续持续观察。</p><p>欢迎大家访问：<a href="https://blog.caozeal.cn/">傲然绝唳的小栈</a></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LangChain学习笔记（一）</title>
    <link href="/2023/07/01/LangChain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/07/01/LangChain%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="LangChain学习笔记（一）"><a href="#LangChain学习笔记（一）" class="headerlink" title="LangChain学习笔记（一）"></a>LangChain学习笔记（一）</h1><blockquote><p>文中大部分都可以在<a href="https://python.langchain.com/">官方文档</a>中找到，示例为自己的实践，有条件可以直接参考官方文档。</p></blockquote><h2 id="1-什么是LangChain"><a href="#1-什么是LangChain" class="headerlink" title="1. 什么是LangChain"></a>1. 什么是LangChain</h2><blockquote><p>LangChain is a framework for developing applications powered by language models. We believe that the most powerful and differentiated applications will not only call out to a language model via an api, but will also:</p><ol><li>Be data-aware: connect a language model to other sources of data</li><li>Be agentic: Allow a language model to interact with its environment</li></ol></blockquote><blockquote><p>LangChain是一个用于开发由语言模型驱动的应用程序框架。我们相信，最强大和有差异化的应用程序不仅会通过API调用语言模型，还会具备以下特点：</p><ol><li>数据感知：将语言模型连接到其他数据源。</li><li>智能代理：允许语言模型与其环境进行交互。</li></ol></blockquote><p>随着chatgpt的火爆，大型语言模型（LLMs）正在成为一种具有变革性的技术，围绕大语言模型的辅助开发框架LangChain也问世了，它不仅可以使我们更方便的调用大语言模型的api，也可以使其与其他的资源（数据源&#x2F;shell&#x2F;api）进行交互，充分发挥大语言模型的能力。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>LangChain有六个模块：</p><ol><li>Model I&#x2F;O(IO模型)：提供与大语言模型进行交互的接口<br><img src="/../resources/langchain_iomodel.jpg" alt="Model_IO"></li><li>Data Connection(数据连接)：提供特定于应用数据的接口<br><img src="/../resources/langchain_dataconnection.jpg" alt="Data_Connection"></li><li>Chains：通用解释为对组件的调用序列，可以将多个调用链接起来</li><li>Memory(记忆模块)： 用于保留一个chain中应用程序的状态</li><li>Agents(代理模块)：提供其他工具的代理，使得chain可以决定并使用某些工具，比如执行shell命令，调用google api进行搜索等</li><li>Callbacks(回调模块)：用于日志记录、监控、流式传输等</li></ol><h2 id="2-构建应用"><a href="#2-构建应用" class="headerlink" title="2. 构建应用"></a>2. 构建应用</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install langchain  <span class="hljs-comment">#安装langchain</span><br>pip intstall openai    <span class="hljs-comment">#安装openai</span><br></code></pre></td></tr></table></figure><ul><li>设置<code>OPENAI_API_KEY</code>环境变量</li></ul><h3 id="2-2-通过大语言模型获取预测"><a href="#2-2-通过大语言模型获取预测" class="headerlink" title="2.2 通过大语言模型获取预测"></a>2.2 通过大语言模型获取预测</h3><p>对大语言模型基础的调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.llms <span class="hljs-keyword">import</span> OpenAI<br><br><span class="hljs-comment"># temperature: 0.0-2.0, 越大越随机；model：默认使用text-davinci-003</span><br>llm = OpenAI(temperature=<span class="hljs-number">0.9</span>, client=<span class="hljs-string">&quot;llms&quot;</span>, model=<span class="hljs-string">&quot;text-davinci-003&quot;</span>)<br><br><span class="hljs-built_in">print</span>(llm.predict(<span class="hljs-string">&quot;列举三种水果&quot;</span>))<br><span class="hljs-comment">#也可以写作</span><br><span class="hljs-built_in">print</span>(llm(<span class="hljs-string">&quot;列举三种水果&quot;</span>))<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">苹果、梨、橘子<br></code></pre></td></tr></table></figure><h3 id="2-3-对对话模型的调用"><a href="#2-3-对对话模型的调用" class="headerlink" title="2.3 对对话模型的调用"></a>2.3 对对话模型的调用</h3><p>聊天模型是大语言模型的变体。与大语言模型不同的是，大语言模型以文本进行交互，聊天模型可以使用<code>AIMessage</code>,<code>HumanMessage</code>,<code>SystemMessage</code>进行交互，分别对应openai中的<code>system</code>,<code>user</code>,<code>assistant</code>角色。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.cache <span class="hljs-keyword">import</span> Base<br><span class="hljs-keyword">from</span> langchain.chat_models <span class="hljs-keyword">import</span> ChatOpenAI<br><span class="hljs-keyword">from</span> langchain.schema <span class="hljs-keyword">import</span> (HumanMessage, SystemMessage)<br><br><span class="hljs-comment"># model 默认使用gpt-3.5-turbo</span><br>chat = ChatOpenAI(temperature=<span class="hljs-number">0.9</span>, client=<span class="hljs-string">&quot;chat&quot;</span>)<br>result = chat.predict_messages(<br>    [<br>        SystemMessage(content=<span class="hljs-string">&quot;以下是AI助手与人类之间的友好对话。&quot;</span>),<br>        HumanMessage(content=<span class="hljs-string">&quot;把这句话翻译为英语：我爱你。&quot;</span>),<br>    ])<br><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">content=<span class="hljs-string">&#x27;The translation of this sentence to English is: &quot;I love you.&quot;&#x27;</span> additional_kwargs=&#123;&#125; example=False<br></code></pre></td></tr></table></figure><p>当然也可以直接以文本进行交互</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(chat.predict(<span class="hljs-string">&quot;把这句话翻译为英语：我爱你。&quot;</span>))<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">I love you.<br></code></pre></td></tr></table></figure><h3 id="2-4-Prompt-templates-提示模板"><a href="#2-4-Prompt-templates-提示模板" class="headerlink" title="2.4 Prompt templates(提示模板)"></a>2.4 Prompt templates(提示模板)</h3><p>便于根据不同的上下文来生成不同的prompt，应用程序调用起来更灵活</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.prompts <span class="hljs-keyword">import</span> (ChatPromptTemplate, SystemMessagePromptTemplate, HumanMessagePromptTemplate)<br><br>system_template = <span class="hljs-string">&quot;你是一个翻译助手，帮助人们把&#123;源语言&#125;翻译为&#123;目标语言&#125;&quot;</span><br>system_message_prompt = SystemMessagePromptTemplate.from_template(system_template)<br>human_template = <span class="hljs-string">&quot;&#123;文本&#125;&quot;</span><br>human_message_prompt = HumanMessagePromptTemplate.from_template(human_template)<br><br>chat_prompt = ChatPromptTemplate.from_messages([system_message_prompt, human_message_prompt])<br><br><span class="hljs-built_in">format</span> = chat_prompt.format_messages(源语言=<span class="hljs-string">&quot;汉语&quot;</span>, 目标语言=<span class="hljs-string">&quot;英语&quot;</span>, 文本=<span class="hljs-string">&quot;我爱你&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">format</span>)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[SystemMessage(content=<span class="hljs-string">&#x27;你是一个翻译助手，帮助人们把汉语翻译为英语&#x27;</span>, additional_kwargs=&#123;&#125;), HumanMessage(content=<span class="hljs-string">&#x27;我爱你&#x27;</span>, additional_kwargs=&#123;&#125;, example=False)]<br></code></pre></td></tr></table></figure><p>用于后续调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">chat = ChatOpenAI(temperature=<span class="hljs-number">0.9</span>, client=<span class="hljs-string">&quot;chat&quot;</span>)<br><span class="hljs-built_in">print</span>(chat.predict_messages(<span class="hljs-built_in">format</span>))<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">content</span>=<span class="hljs-string">&#x27;I love you.&#x27;</span> additional_kwargs=&#123;&#125; example=<span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h3 id="2-5-Chains"><a href="#2-5-Chains" class="headerlink" title="2.5 Chains"></a>2.5 Chains</h3><p>我们也可以使用chain来组装model和prompt</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在2.4的基础上添加</span><br><span class="hljs-keyword">from</span> langchain <span class="hljs-keyword">import</span> LLMChain<br><br>chain = LLMChain(llm=chat, prompt=chat_prompt)<br>result = chain.run(源语言=<span class="hljs-string">&quot;汉语&quot;</span>, 目标语言=<span class="hljs-string">&quot;英语&quot;</span>, 文本=<span class="hljs-string">&quot;我爱你&quot;</span>)<br><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">I love you.<br></code></pre></td></tr></table></figure><h3 id="2-6-Agents"><a href="#2-6-Agents" class="headerlink" title="2.6 Agents"></a>2.6 Agents</h3><p>使用代理来调用工具以完成更复杂的任务。使用代理分为三步：</p><ol><li>选择语言模型：LLM&#x2F;Chat Model</li><li>选择工具：例如，Google Search，Shell, ChatGPT Plugins等</li><li>构建代理</li></ol><p>比如我们可以使用SerpAPI通过谷歌搜索某些东西并进行简单的数学计算：</p><ul><li>安装包：<code>pip install google-search-results</code></li><li>设置环境变量：<code>SERPAPI_API_KEY</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.agents <span class="hljs-keyword">import</span> AgentType, initialize_agent, load_tools<br><span class="hljs-keyword">from</span> langchain.llms <span class="hljs-keyword">import</span> OpenAI<br><br>llm = OpenAI(temperature=<span class="hljs-number">0</span>, client=<span class="hljs-string">&quot;agent&quot;</span>, model=<span class="hljs-string">&quot;text-davinci-003&quot;</span>)<br><br><span class="hljs-comment"># serpapi: 可以用来调用google的api，llm-math：进行数学计算</span><br>tools = load_tools([<span class="hljs-string">&quot;serpapi&quot;</span>, <span class="hljs-string">&quot;llm-math&quot;</span>], llm)<br><br><span class="hljs-comment"># AgentType.ZERO_SHOT_REACT_DESCRIPTION：直译就是零样本_反应_描述，仅通过描述来确定使用哪个工具</span><br><span class="hljs-comment"># verbose=True： 显示详细描述（可以理解为AI的心路历程）</span><br>agent = initialize_agent(tools, llm, AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=<span class="hljs-literal">True</span>)<br><br><span class="hljs-built_in">print</span>(agent.run(<span class="hljs-string">&quot;北京昨天最高气温是多少摄氏度？然后算一下这个数字的平方根&quot;</span>))<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; Entering new  chain...<br> I need to find the temperature first, <span class="hljs-keyword">then</span> calculate the square root<br>Action: Search<br>Action Input: <span class="hljs-string">&quot;Beijing yesterday highest temperature&quot;</span><br>Observation: Beijing Temperature Yesterday. Maximum temperature yesterday: 102 °F (at 5:00 pm) Minimum temperature yesterday: 72 °F (at 5:00 am) Average temperature ...<br>Thought: I need to convert the temperature to Celsius<br>Action: Calculator<br>Action Input: 102 Fahrenheit to Celsius<br>Observation: Answer: 38.888888888888886<br>Thought: I now need to calculate the square root<br>Action: Calculator<br>Action Input: 38.888888888888886^(1/2)<br>Observation: Answer: 6.236095644623235<br>Thought: I now know the final answer<br>Final Answer: The highest temperature <span class="hljs-keyword">in</span> Beijing yesterday was 38.888888888888886°C and the square root of this number is 6.236095644623235.<br><br>&gt; Finished chain.<br>The highest temperature <span class="hljs-keyword">in</span> Beijing yesterday was 38.888888888888886°C and the square root of this number is 6.236095644623235.<br></code></pre></td></tr></table></figure><p>功能很强大，但实际体验下来不是特别美好，一是不稳定，经常需要查询很多次才能得到结果，二是描述稍微模糊或者复杂一点，得到的结果可能就是错误的，或者没法带入到下一步，直接报错 <del>摆烂</del>。<br>serpapi注册用户每月有100次免费的谷歌调用，经不起折腾，不过我们可以来尝试下免费的duckduckgo search <del>(鸭鸭狗）</del>)</p><ul><li>安装<code>pip install duckduckgo-search</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.llms <span class="hljs-keyword">import</span> OpenAI<br><span class="hljs-keyword">from</span> langchain.agents <span class="hljs-keyword">import</span> initialize_agent, AgentType, load_tools<br><br>llm = OpenAI(temperature=<span class="hljs-number">0</span>, client=<span class="hljs-string">&quot;agent&quot;</span>, model=<span class="hljs-string">&quot;text-davinci-003&quot;</span>)<br>tools = load_tools([<span class="hljs-string">&quot;ddg-search&quot;</span>, <span class="hljs-string">&quot;llm-math&quot;</span>], llm)<br>agent = initialize_agent(tools, llm, AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(agent.run(<span class="hljs-string">&quot;北京昨天最高气温是多少摄氏度？然后算一下这个数字的平方根&quot;</span>))<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; Entering new  chain...<br> I need to find the highest temperature <span class="hljs-keyword">in</span> Beijing yesterday and <span class="hljs-keyword">then</span> calculate the square root of that number<br>Action: duckduckgo_search<br>Action Input: <span class="hljs-string">&quot;Beijing highest temperature yesterday&quot;</span><br>Observation: By Reuters BEIJING, June 22 — The temperature <span class="hljs-keyword">in</span> Beijing breached 106 degrees Fahrenheit on Thursday and shattered the record <span class="hljs-keyword">for</span> the hottest day <span class="hljs-keyword">in</span> June as heatwaves that had seared nort<br>hern... On Friday, Beijing baked <span class="hljs-keyword">in</span> temperatures as high as 40.3C, after sizzling at 41.1C on Thursday, the second-hottest day recorded by the Chinese capital <span class="hljs-keyword">in</span> modern <span class="hljs-built_in">times</span>. Beijing<span class="hljs-string">&#x27;s all-time high of ... The city experienced its all-time recorded high of 41.9 C (107 F) on July 24, 1999. Chinese meteorologists say the current heat wave was caused by warm air masses associated with high-pressure ridges in the atmosphere, </span><br><span class="hljs-string">compounded by thin cloud covers and long daylight hours around the summer solstice. Last week, Beijing recorded its highest temperature for mid-June, with weather officials warning the public to stay indoors as the mercury hit 39.4C. With Agence France-Presse and Reuters... Beijing recorded a high temperature of 41.1 C yesterday (Jun 23) as the capital city continues to experience an ongoing heatwave, according to a report from Beijing News (新京报). This isn&#x27;</span>t the first <span class="hljs-keyword">time</span> the city has seen the heat cranked up to over 41 C, but the first <span class="hljs-keyword">time</span> it<span class="hljs-string">&#x27;s happened in June.</span><br><span class="hljs-string">Thought: I now have the highest temperature in Beijing yesterday</span><br><span class="hljs-string">Action: Calculator</span><br><span class="hljs-string">Action Input: 41.1</span><br><span class="hljs-string">Observation: Answer: 41.1</span><br><span class="hljs-string">Thought: I now know the final answer</span><br><span class="hljs-string">Final Answer: The highest temperature in Beijing yesterday was 41.1°C and its square root is 6.4.</span><br></code></pre></td></tr></table></figure><p>一次查询便得到了结果，效果似乎更好，不过日期错了，并不是昨天😭</p><p>也可以调用本地shell:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.llms <span class="hljs-keyword">import</span> OpenAI<br><span class="hljs-keyword">from</span> langchain.agents <span class="hljs-keyword">import</span> initialize_agent, AgentType, load_tools<br><br>llm = OpenAI(temperature=<span class="hljs-number">0</span>, client=<span class="hljs-string">&quot;shell&quot;</span>, model=<span class="hljs-string">&quot;text-davinci-003&quot;</span>)<br><br>tools = load_tools([<span class="hljs-string">&quot;terminal&quot;</span>, <span class="hljs-string">&quot;llm-math&quot;</span>], llm)<br>self_ask_with_search = initialize_agent(<br>    tools, llm, agent=AgentType.CHAT_ZERO_SHOT_REACT_DESCRIPTION, verbose=<span class="hljs-literal">True</span><br>)<br>self_ask_with_search.run(<span class="hljs-string">&quot;get the memory info by GB&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-7-Memory"><a href="#2-7-Memory" class="headerlink" title="2.7 Memory"></a>2.7 Memory</h3><p>维护程序状态，拥有上下文记忆</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.prompts <span class="hljs-keyword">import</span> (ChatPromptTemplate, SystemMessagePromptTemplate, HumanMessagePromptTemplate, MessagesPlaceholder)<br><span class="hljs-keyword">from</span> langchain.chains <span class="hljs-keyword">import</span> ConversationChain<br><span class="hljs-keyword">from</span> langchain.chat_models <span class="hljs-keyword">import</span> ChatOpenAI<br><span class="hljs-keyword">from</span> langchain.memory <span class="hljs-keyword">import</span> ConversationBufferMemory<br><br>prompt = ChatPromptTemplate.from_messages([<br>    SystemMessagePromptTemplate.from_template(<br>        <span class="hljs-string">&quot;以下是AI助手与人类之间的友好对话。&quot;</span><br>    ),<br>    MessagesPlaceholder(variable_name=<span class="hljs-string">&quot;history&quot;</span>),<br>    HumanMessagePromptTemplate.from_template(<span class="hljs-string">&quot;&#123;input&#125;&quot;</span>)<br>])<br><br>llm = ChatOpenAI(temperature=<span class="hljs-number">0</span>, client=<span class="hljs-string">&quot;memory&quot;</span>)<br>memory = ConversationBufferMemory(return_messages=<span class="hljs-literal">True</span>)<br>conversation = ConversationChain(memory=memory, prompt=prompt, llm=llm)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    user = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;用户: &quot;</span>)<br>    answer = conversation.predict(<span class="hljs-built_in">input</span> = user)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;AI助手：&quot;</span>, answer)<br></code></pre></td></tr></table></figure><p>我们与AI进行交互：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">用户: 你好<br>AI助手： 你好！有什么我可以帮助你的吗？<br></code></pre></td></tr></table></figure><p>接下来验证确实存在记忆：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">用户: 我说的是上一句话是什么<br>AI助手： 你说的上一句话是<span class="hljs-string">&quot;你好&quot;</span>。<br></code></pre></td></tr></table></figure><h2 id="3-最后"><a href="#3-最后" class="headerlink" title="3. 最后"></a>3. 最后</h2><p>LangChain的大体功能如上，与LLMs一样，目前也在蓬勃发展阶段，由于大语言模型的不稳定性，现在使用起来还有很多不尽如人意的地方，但是我们也可以看到其潜力和愿景。个人觉得，agents部分是最吸引人的地方，将LLMs的能力由文本延伸到程序之外，极大地提升了想象空间。<br>更多内容可以查看<a href="https://python.langchain.com/">官方文档</a>。</p><h2 id="附：参考链接-文档"><a href="#附：参考链接-文档" class="headerlink" title="附：参考链接&amp;文档"></a>附：参考链接&amp;文档</h2><ol><li><a href="https://python.langchain.com/">官方文档</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OpenAI API 提示词工程最佳实践</title>
    <link href="/2023/06/22/OpenAI%20API%20%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B7%A5%E7%A8%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/2023/06/22/OpenAI%20API%20%E6%8F%90%E7%A4%BA%E8%AF%8D%E5%B7%A5%E7%A8%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="OpenAI-API-提示词工程最佳实践"><a href="#OpenAI-API-提示词工程最佳实践" class="headerlink" title="OpenAI API 提示词工程最佳实践"></a>OpenAI API 提示词工程最佳实践</h1><p>如何向GPT-3和Codex提供清晰有效的指令</p><blockquote><p>翻译自OpenAI官方文档，<a href="https://help.openai.com/en/articles/6654000-best-practices-for-prompt-engineering-with-openai-apis">原文链接</a></p></blockquote><h2 id="提示词工程的工作原理"><a href="#提示词工程的工作原理" class="headerlink" title="提示词工程的工作原理"></a>提示词工程的工作原理</h2><p>由于指令跟随模型的训练方式或训练数据的原因，存在一些特定的提示词格式，这些格式在任务中表现出色且更好地与任务相匹配。以下是一些我们发现可靠有效的提示词格式，但你也可以自由探索不同的格式，以找到最适合你任务的方式。</p><h2 id="经验法则和示例"><a href="#经验法则和示例" class="headerlink" title="经验法则和示例"></a>经验法则和示例</h2><p>注意：<code>&#123;在此输入文本&#125;</code>是实际文本&#x2F;上下文的占位符。</p><h3 id="1-使用最新模型"><a href="#1-使用最新模型" class="headerlink" title="1. 使用最新模型"></a>1. 使用最新模型</h3><p>为了获得最佳结果，我们通常建议使用最新、功能最强大的模型。截至2022年11月，文本生成的最佳选择是“text-davinci-003”模型，代码生成的最佳选择是“code-davinci-002”模型。</p><h3 id="2-将指令放在提示词的开头，并使用-或”””来分隔指令和上下文"><a href="#2-将指令放在提示词的开头，并使用-或”””来分隔指令和上下文" class="headerlink" title="2. 将指令放在提示词的开头，并使用###或”””来分隔指令和上下文"></a>2. 将指令放在提示词的开头，并使用###或”””来分隔指令和上下文</h3><p>效果较差 ❌：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">将下面的文本总结为最重要的要点的项目符号列表。</span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123;在此输入文本&#125;</span><br></code></pre></td></tr></table></figure><p>更好 ✅：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">将下面的文本总结为最重要的要点的项目符号列表。<br>文本：<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&#123;在此输入文本&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-在所需的上下文、结果、长度、格式、风格等方面要具体、描述详细"><a href="#3-在所需的上下文、结果、长度、格式、风格等方面要具体、描述详细" class="headerlink" title="3. 在所需的上下文、结果、长度、格式、风格等方面要具体、描述详细"></a>3. 在所需的上下文、结果、长度、格式、风格等方面要具体、描述详细</h3><p>对于上下文、结果、长度、格式、风格等要具体说明<br>效果较差 ❌：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">写一首关于OpenAI的诗。<br></code></pre></td></tr></table></figure><p>更好 ✅：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">写一首简短的鼓舞人心的诗，关于<span class="hljs-variable">OpenAI</span>，重点关注最近<span class="hljs-variable">DALL</span><span class="hljs-operator">-</span><span class="hljs-built_in">E</span>产品的发布（<span class="hljs-variable">DALL</span><span class="hljs-operator">-</span><span class="hljs-built_in">E</span>是一种文本到图像的机器学习模型），采用<span class="hljs-punctuation">&#123;</span>著名诗人<span class="hljs-punctuation">&#125;</span>的风格。<br></code></pre></td></tr></table></figure><h3 id="4-通过示例来明确所需的输出格式（示例1，示例2）"><a href="#4-通过示例来明确所需的输出格式（示例1，示例2）" class="headerlink" title="4. 通过示例来明确所需的输出格式（示例1，示例2）"></a>4. 通过示例来明确所需的输出格式（示例1，示例2）</h3><p>效果较差 ❌：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">从下面的文本中提取实体。提取以下4种实体类型：公司名称、人名、具体主题和主题。</span><br><span class="language-xml">文本：</span><span class="hljs-template-variable">&#123;文本&#125;</span><br></code></pre></td></tr></table></figure><p>展示和说明 - 当显示特定的格式要求时，模型的响应更好。这也使得以可靠的方式程序化地解析多个输出更加容易。<br>更好 ✅：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">从下面的文本中提取重要的实体。首先提取所有公司名称，然后提取所有人名，然后提取符合内容的具体主题，最后提取总体主题。<br><br>期望格式：<br>公司名称： <span class="hljs-variable">&lt;以逗号分隔的公司名称列表&gt;</span><br>人名：-||<span class="hljs-string">-</span><br><span class="hljs-string">具体主题：-</span>||<span class="hljs-string">-</span><br><span class="hljs-string">总体主题：-</span>||<span class="hljs-string">-</span><br><span class="hljs-string"></span><br><span class="hljs-string">文本：&#123;文本&#125;</span><br></code></pre></td></tr></table></figure><h3 id="5-首先尝试零样本提示-zero-shot-，然后进行少样本提示-few-shot-（示例），如果两者都不起作用，再进行微调。"><a href="#5-首先尝试零样本提示-zero-shot-，然后进行少样本提示-few-shot-（示例），如果两者都不起作用，再进行微调。" class="headerlink" title="5. 首先尝试零样本提示(zero-shot)，然后进行少样本提示(few-shot)（示例），如果两者都不起作用，再进行微调。"></a>5. 首先尝试零样本提示(zero-shot)，然后进行少样本提示(few-shot)（示例），如果两者都不起作用，再进行微调。</h3><p>✅ 零样本提示</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">从下面的文本中提取关键词。</span><br><span class="language-xml">文本：</span><span class="hljs-template-variable">&#123;文本&#125;</span><span class="language-xml"></span><br><span class="language-xml">关键词：</span><br></code></pre></td></tr></table></figure><p>✅ 少样本提示 - 提供一些示例</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">从以下对应的文本中提取关键词。</span><br><span class="language-xml">文本 1：Stripe提供API，供Web开发人员将支付处理集成到其网站和移动应用程序中。</span><br><span class="language-xml">关键词 1：Stripe，支付处理，API，Web开发人员，网站，移动应用程序</span><br><span class="language-xml">文本 2：OpenAI训练了先进的语言模型，非常擅长理解和生成文本。我们的API提供对这些模型的访问，并可用于解决几乎涉及语言处理的任何任务。</span><br><span class="language-xml">关键词 2：OpenAI，语言模型，文本生成，API</span><br><span class="language-xml">文本 3：</span><span class="hljs-template-variable">&#123;文本&#125;</span><span class="language-xml"></span><br><span class="language-xml">关键词 3：</span><br></code></pre></td></tr></table></figure><p>✅ 微调 - 参见微调的最佳实践，请点击<a href="https://docs.google.com/document/d/1h-GTjNDDKPKU_Rsd0t1lXCAnHltaXTAzQ8K2HRhQf9U/edit#">此处</a>。</p><h3 id="6-减少“琐碎”和不精确的描述"><a href="#6-减少“琐碎”和不精确的描述" class="headerlink" title="6.减少“琐碎”和不精确的描述"></a>6.减少“琐碎”和不精确的描述</h3><p>效果较差 ❌：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">对于此产品的描述应该相对简短，只有几句话，并且不要太多。<br></code></pre></td></tr></table></figure><p>更好 ✅：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">使用3到5个句子的段落来描述这个产品。<br></code></pre></td></tr></table></figure><h3 id="7-不要仅仅说不要做什么，而是说明应该做什么。"><a href="#7-不要仅仅说不要做什么，而是说明应该做什么。" class="headerlink" title="7.不要仅仅说不要做什么，而是说明应该做什么。"></a>7.不要仅仅说不要做什么，而是说明应该做什么。</h3><p>效果较差 ❌：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">以下是客服和客户之间的对话。请勿询问用户名或密码。请勿重复。<br>客户：我无法登录我的账户。<br>客服：<br></code></pre></td></tr></table></figure><p>更好 ✅：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">以下是客服和客户之间的对话。客服将尝试诊断问题并提出解决方案，同时避免询问与个人身份信息（PII）相关的问题。而是代替询问个人身份信息（例如用户名或密码），请引导用户参考帮助文章www.samplewebsite.<span class="hljs-keyword">com</span>/<span class="hljs-keyword">help</span>/faq。<br>客户：我无法登录我的账户。<br>客服：<br></code></pre></td></tr></table></figure><h3 id="8-特定于代码生成-使用“引导词”（leading-words）来引导模型朝特定模式的方向发展"><a href="#8-特定于代码生成-使用“引导词”（leading-words）来引导模型朝特定模式的方向发展" class="headerlink" title="8.特定于代码生成 - 使用“引导词”（leading words）来引导模型朝特定模式的方向发展"></a>8.特定于代码生成 - 使用“引导词”（leading words）来引导模型朝特定模式的方向发展</h3><p>效果较差 ❌：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 编写一个简单的Python函数，它能够：</span><br><span class="hljs-meta"># 1. 向我询问一个英里数</span><br><span class="hljs-meta"># 2. 将英里转换为公里</span><br></code></pre></td></tr></table></figure><p>在下面的代码示例中，添加“import”提示可以让模型知道它应该以Python语言开始编写。（同样，“SELECT”是一个良好的提示，表示开始一个SQL语句。）<br>更好 ✅：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-meta"># 编写一个简单的Python函数，它能够：</span><br><span class="hljs-meta"># 1. 向我询问一个英里数</span><br><span class="hljs-meta"># 2. 将英里转换为公里</span><br><br><span class="hljs-keyword">import</span><br></code></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>通常，我们发现模型(model)和温度(temperature)是最常用的用于修改模型输出的参数。</p><ol><li>model - 性能更高的模型更昂贵且延迟更高。</li><li>temperature - 衡量模型输出较低可能性标记(token)的频率。temperature越高，输出越随机（通常更具创造力）。然而，这与“真实性”不同。对于大多数事实类用例，例如数据提取和真实问答，temperature为0最合适。</li><li>max_tokens（最大标记长度）- 不控制输出的长度，而是限制生成的token数量。理想情况下，您不会经常达到此限制，因为模型会在它认为已完成时停止，或者当它遇到您定义的停止序列时停止。</li><li>stop（停止序列）- 一组字符（标记），生成这些字符时，文本生成将停止。<br>有关其他参数说明，请参阅<a href="https://platform.openai.com/docs/api-reference/completions/create">API参考</a>。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《被讨厌的勇气》（一）</title>
    <link href="/2023/03/14/%E3%80%8A%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/03/14/%E3%80%8A%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="《被讨厌的勇气》（一）"><a href="#《被讨厌的勇气》（一）" class="headerlink" title="《被讨厌的勇气》（一）"></a>《被讨厌的勇气》（一）</h1><p><img src="/../resources/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%E5%B0%81%E9%9D%A2.jpg" alt="被讨厌的勇气封面"></p><blockquote><p>世界极其简单，人们随时都可以获得幸福。</p></blockquote><p>这本书仿佛有着魔力一般，吸引着我不停地读下去，一页一页翻到最后，长呼一口气。我仿佛书中的青年一样茫然、困惑，“世界是矛盾丛生的一片混沌”，而青年则被“诸多烦恼缠绕”，一路走下来，阴霾的天空洒下仿佛洒下一缕阳光，接下来是层云重新覆盖还是风起云散，还得看自己的思索和勇气。</p><p>本书围绕青年和哲人的对话、辩论展开，将阿德勒的心理学徐徐铺展到我们面前，对话体，一下子就想到了《论语》、《理想国》，很容易带入其中，或旁观或参与其中。“阿德勒心理学”被称为现代心理学、个体心理学，不同于原因论，“阿德勒心理学”专注于寻找解决方案，更像是一种哲学，提供看待世界的一个视角。“动机在杭州”写的推荐序二 《自我的加锁和解放》总结的很棒，梳理出一条线贯穿整本书。</p><p>他说，“阿德勒最重要的思想主题，是对自我的解放。阿德勒整个理论体系，都在试图把人从这种束缚中解脱出来，让人重获心灵自由。”</p><p>我们需要挣脱的束缚有三个：过去、人际关系、未来。</p><p>第一个束缚来自<strong>过去</strong>。在多数人的认知里，自己的过去尤其是童年的经历会对自己产生不可撼动的影响，“人”是过去的产物。但阿德勒告诉我们，重要的是不是过去，而是我们怎么看待过去，我们对过去的看法，是可以改变的。我们对过去的过度依赖，使我们下意识逃避责任，把一切都推给过去，自己则躲在自洽的山洞里，不愿出来。我们需要挣脱<strong>过去</strong>的束缚，拿出承担责任的勇气和决心，自己随时都可以<strong>改变</strong>。</p><p>第二个束缚来自<strong>人际关系</strong>。我们会被他人的期待和评价所挟持，也会对他人抱有期待或评头论足。阿德勒认为，理想的人际关系大概是“我爱你，但与你无关”，每个人的课题都是分离又独特的，我怎么爱你，这是我的课题，而你要不要接受，这是你的课题。每个人专注与自己的课题，过自己的人生，人和人之间就没那么多纠结和烦恼。这一点也呼应书名，我们是否有着不去寻求认可，不活在他人期待，不自卑，追求自由的勇气？书中会有更多的讨论。</p><p>第三个束缚来自<strong>未来</strong>。当我们认为只有成功才是人生真正开始的时候，我们就把现在贬低成了实现未来的工具。<strong>“当你急着奔向未来的时候，说明你已经不喜欢现在了”</strong>。但正如过去不会决定现在一样，现在也不应该成为实现未来的工具。人生正是有一个个名为当下的片段构成，我们要做的是认真跳好每一段当下的舞蹈。</p><p>当我们从这些束缚中解脱出来后，会发现我们其实一直很自由，真正让我们裹足不前的，原来正是我们自己。挣脱束缚需要决心和勇气，承担这种自由和责任，更需要无畏的勇气。</p><p>受其鼓舞，我在阅读的时候也不止一次的下决心要改变，去做些什么。但习惯拥有引力，怠惰磨损勇气，一不留神，又已在了重重束缚之下，弄不好我也会如第二部《幸福的勇气》中青年一开始那样，发现阿德勒的思想并没有如预想那般轻易改变自己而怒斥阿德勒思想为妖言惑众，一厢情愿的理想主义，枉顾现实的书屋中的哲学。一口气又看完了《幸福的勇气》，终于鼓起勇气要记录点什么，或许是读书笔记，或许有碎碎念，或许只是大段大段地摘抄，但，改变就从现在开始，什么时候改变都不晚。</p><p><img src="/../resources/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%941.jpg" alt="被讨厌的勇气插图"></p>]]></content>
    
    
    
    <tags>
      
      <tag>被讨厌的勇气</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java日志相关介绍</title>
    <link href="/2023/03/02/java%E6%97%A5%E5%BF%97%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/03/02/java%E6%97%A5%E5%BF%97%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="java日志相关介绍"><a href="#java日志相关介绍" class="headerlink" title="java日志相关介绍"></a>java日志相关介绍</h1><h3 id="一、初期日志记录"><a href="#一、初期日志记录" class="headerlink" title="一、初期日志记录"></a>一、初期日志记录</h3><p>回想一下，自己在刚接触java的时候是怎么记录日志信息的。通常我们会使用 <code>System.out.println()</code>输出调试日志信息，使用 <code>System.err.println()</code>输出错误日志信息，使用 <code>e.printStackTrace()</code>来输出异常堆栈信息。</p><p>实际上，在日志框架出现之前，大家都是这样使用的；而现在则会被前辈们千叮咛万嘱咐，不要使用这些来记录日志信息。而为什么有了日志框架就不能使用这些原始的记录方式了，大家有没有仔细思考过？</p><p>其实sonar中有一条规则很详细地为我们解释了原因：</p><blockquote><h3 id="Standard-outputs-should-not-be-used-directly-to-log-anything"><a href="#Standard-outputs-should-not-be-used-directly-to-log-anything" class="headerlink" title="Standard outputs should not be used directly to log anything"></a>Standard outputs should not be used directly to log anything</h3><ul><li>异味</li><li>主要</li><li>主要代码</li></ul><p>When logging a message there are several important requirements which must be fulfilled:</p><ul><li>The user must be able to easily retrieve the logs</li><li>The format of all logged message must be uniform to allow the user to easily read the log</li><li>Logged data must actually be recorded</li><li>Sensitive data must only be logged securely</li></ul><p>If a program directly writes to the standard outputs, there is absolutely no way to comply with those requirements. That’s why defining and using a dedicated logger is highly recommended.</p></blockquote><p>即，标准输出流已经无法满足我们对于日志记录的需求了，这时日志记录框架便诞生了。</p><h3 id="二、日志框架演进概述"><a href="#二、日志框架演进概述" class="headerlink" title="二、日志框架演进概述"></a>二、日志框架演进概述</h3><p>通常我们目前使用的框架是slf4j和logback结合的方式，你是否有过疑惑，记录日志为什么要是用两个日志框架呢，他们的职责又分别是什么？</p><h4 id="1-log4j"><a href="#1-log4j" class="headerlink" title="1.log4j"></a>1.log4j</h4><p>早年，使用<strong>log4j</strong>框架来记录日志，使用如下代码来输出日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.log4j.Logger;<br>\\省略<br><span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(Test.class);<br>logger.trace(<span class="hljs-string">&quot;trace&quot;</span>);<br>\\省略<br></code></pre></td></tr></table></figure><h4 id="2-J-U-L"><a href="#2-J-U-L" class="headerlink" title="2. J.U.L"></a>2. J.U.L</h4><p>但是后续，JDK加入了<strong>J.U.L</strong>(java.util.logging)，推出了官方的日志记录框架。这是一部分人想要把自己项目中的日志记录框架改为J.U.L，需要怎么做呢？找出所有使用log4j api的代码，将其手动一行一行改为J.U.L的api，即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.logging.Logger；<br>\\省略<br><span class="hljs-type">Logger</span> <span class="hljs-variable">loggger</span> <span class="hljs-operator">=</span> Logger.getLogger(Test.class.getName()); <br>logger.finest(<span class="hljs-string">&quot;finest&quot;</span>);<br>\\省略<br></code></pre></td></tr></table></figure><h3 id="3-J-C-L"><a href="#3-J-C-L" class="headerlink" title="3. J.C.L"></a>3. J.C.L</h3><p>可以看出，切换日志记录框架十分不方便，日后再出现更优秀的日志记录框架该怎么办呢。这时候Apache的<strong>JCL</strong>（commons-logging）诞生了。JCL是一个Log Facade（即日志门面框架），只提供 Log API，不提供实现，然后有 Adapter 来使用 Log4j 或者 JUL 作为Log Implementation。真正干事的还是后方的日志记录框架（log4j、J.U.L）。目的就是之后再出现更优秀的日志记录框架的时候，开发者不用改代码（即不用切换log api），只需改配置就可平滑切换到新的日志记录框架中。</p><h4 id="4-SLF4J-Logback"><a href="#4-SLF4J-Logback" class="headerlink" title="4. SLF4J  &amp;  Logback"></a>4. SLF4J  &amp;  Logback</h4><p>事情到这里似乎已经尘埃落定了，完成了Log Facade + Log 两层框架的体系。这套框架也具备了上面所说的日志记录的四项能力。</p><p>但是我们目前使用的日志门面框架通常是SLF4J，而不是最初的JCL。那SLF4J是具备了哪些更优秀的品质，而让我们去选择了它呢？其中比较重要的一点是SLF4J中的占位符模式，能够一定程度上减少字符串拼接的开销。</p><p>JCL推荐写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>    logger.debug(<span class="hljs-string">&quot;start process request, url:&quot;</span> + url);<br>&#125;<br></code></pre></td></tr></table></figure><p>SLF4J写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">logger.debug(<span class="hljs-string">&quot;start process request, url:&#123;&#125;&quot;</span>, url);<br></code></pre></td></tr></table></figure><p>logback则是继承自log4j，增加了异步logger、filter等特性。</p><h4 id="5-Log4j2"><a href="#5-Log4j2" class="headerlink" title="5. Log4j2"></a>5. Log4j2</h4><p>包括日志门面框架log4j-api和日志记录框架log4j-core，由维护log4j的人开发而来，不兼容log4j</p><p>下面放两个各框架间的关系图来感受下：</p><p><img src="/../resources/java%E6%97%A5%E5%BF%97/java%E6%97%A5%E5%BF%97.png" alt="img"></p><p><img src="/../resources/java%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6.webp" alt="img"></p><p>下面以SLF4J和Logback为例来讲一下日志框架使用：</p><h3 id="三、Logback"><a href="#三、Logback" class="headerlink" title="三、Logback"></a>三、Logback</h3><blockquote><p>Logback is intended as a successor to the popular log4j project</p></blockquote><p>这里就不从头说logback的所有配置了，logback的核心配置都在logback.xml文件中，这里讲几个常用的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">scan</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">scanPeriod</span>=<span class="hljs-string">&quot;30 seconds&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">statusListener</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.status.NopStatusListener&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;stdout&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>$&#123;logback.stdout.level&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Target</span>&gt;</span>System.out<span class="hljs-tag">&lt;/<span class="hljs-name">Target</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span><br>   %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;[%-5level][%thread][%logger&#123;20&#125;:%L] %msg%n<br><span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;R&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">File</span>&gt;</span>$&#123;LOG_HOME&#125;/$&#123;SYSTEM_NAME&#125;_stdout_$&#123;ip&#125;_$&#123;port&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">File</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span><br>   %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;[%-5level][%thread][%logger&#123;20&#125;:%L] %msg%n<br><span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/$&#123;SYSTEM_NAME&#125;_stdout_$&#123;ip&#125;_$&#123;port&#125;.%d.log<br><span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;$&#123;logback.root.level&#125;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;stdout&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;R&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>配置文件语法:</p><ul><li>结构：<code>&lt;configuration&gt;</code>元素、0个或多个 <code>&lt;appender&gt;</code>元素、0个或多个 <code>&lt;logger&gt;</code>元素、最多一个 <code>&lt;root&gt;</code>元素</li><li><img src="/../resources/java%E6%97%A5%E5%BF%97/3.image" alt="logback配置"></li><li>标签名大小写敏感</li></ul></li><li><p><code>&lt;configuration&gt;</code>：logback 将写入日志事件的任务委托给一个名为 appender 的组件。</p><ul><li><code>debug</code>：控制是否输出logback本身的一些状态信息</li><li><img src="/../resources/java%E6%97%A5%E5%BF%97/4.image" alt="logback状态信息.png"></li><li><code>scan=&quot;true&quot; </code>当配置文件更改时，自动加载配置，默认扫描间隔1min</li><li><code>scanPeriod=&quot;30 seconds&quot;</code>每30s自动扫描一次配置看是否有更改</li></ul></li><li><p><code>&lt;statusListener&gt;</code>：状态信息监听器</p><ul><li><code>OnConsoleStatusListener</code>：同 <code>debug=true</code>，将状态信息打印到控制台中</li><li><pre><code class="language-java">protected PrintStream getPrintStream() &#123;    return System.out;&#125;<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- `NopStatusListener`：丢弃所有状态信息<br>- ```java<br>  <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> addStatusEvent(Status status) &#123;<br>      // <span class="hljs-keyword">nothing</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">do</span><br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><code>OnErrorConsoleStatusListener</code>：在控制台打印错误信息</li><li><pre><code class="language-java">protected PrintStream getPrintStream() &#123;    return System.err;&#125;<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">- `&lt;appender&gt;`：<br><br>  - ![appenderSyntax](../resources/java日志/<span class="hljs-number">5</span>.image)<br>  - `name`：appender的名字，用于下文logger或root引用<br>  - `class`：appender所采用的具体类<br>    - ![appenderClassDiagram](../resources/java日志/<span class="hljs-number">6</span>.image)<br>    - `ch.qos.logback.core.ConsoleAppender`：将日志事件附加到控制台，就是通过 *System.out* 或者 *System.err* 来进行输出。默认通过前者。<br>    - `ch.qos.logback.core.rolling.RollingFileAppender`：将日志事件输出到文件中。通过 `file` 来指定目标文件。在满足了特定的条件之后，将日志输出到另外一个文件。<br>  - `filter`<br>    - `ch.qos.logback.classic.filter.ThresholdFilter`：基于给定的临界值来过滤事件。如果事件的级别等于或高于给定的临界值，当调用 `decide()` 时，`ThresholdFilter` 将会返回 `NEUTRAL`。但是事件的级别低于临界值将会被拒绝。<br>    - `ch.qos.logback.classic.filter.LevelFilter`：事件的级别与配置的级别相等，会调用 `onMatch`属性配置，不相等会调用 `OnMismatch`属性配置<br>  - `Target`<br>    - `ConsoleAppender`使用，设置为*System.out* 或 *System.err*。默认为 *System.out*<br>  - `encoder`：`encoder` 将日志事件转换为字节数组，同时将字节数组写入到一个 `OutputStream` 中。<br>    - `pattern`：`PatternLayoutEncoder`<br>  - `rollingPolicy`<br>    - `TimeBasedRollingPolicy`：<br>    - `SizeAndTimeBasedRollingPolicy`：<br>- `&lt;logger&gt;`：<br><br>  - `name`<br>  - `level`：TRACE，DEBUG，INFO，WARN，ERROR，ALL，OFF，INHERITED，NULL。当 `level` 的值为 INHERITED 或 NULL 时，将会强制 logger 继承上一层的级别<br>  - `&lt;appender-ref&gt;`：使用的appender，会继承上一级的appender<br>- `&lt;root&gt;`：与 `&lt;logger&gt;`相似，根logger，不能设置name、additivity，level不能设置为INHERITED，NULL。<br><br>### 四、SLF4J<br><br>- 创建Logger<br>  - `Logger logger = LoggerFactory.getLogger(HelloWorld.class)<span class="hljs-comment">;`</span><br>  - 集成lombok插件，可以在类上使用 `@Slf4j`创建<br>- 使用<br>  - `logger.info(<span class="hljs-string">&quot;some message&quot;</span>)<span class="hljs-comment">;`</span><br>  - `logger.error(<span class="hljs-string">&quot;some message&quot;</span>, e)`<br>  - 占位符模式：`logger.debug(<span class="hljs-string">&quot;some message: &#123;&#125;&quot;</span>, message, e)`<br>  - Fluent Logging API（slf4j-api <span class="hljs-number">2.0</span>.<span class="hljs-number">0</span>版本以上）：<br>    - `logger.atInfo().log(<span class="hljs-string">&quot;some message&quot;</span>)`<br>    - ` logger.atDebug().addArgument(newT).addArgument(oldT).log(<span class="hljs-string">&quot;Temperature set to &#123;&#125;. Old temperature was &#123;&#125;.&quot;</span>)<span class="hljs-comment">;`</span><br>    - `logger.atDebug().addKeyValue(<span class="hljs-string">&quot;oldT&quot;</span>, oldT).addKeyValue(<span class="hljs-string">&quot;newT&quot;</span>, newT).log(<span class="hljs-string">&quot;Temperature changed.&quot;</span>)<span class="hljs-comment">;` == `logger.debug(&quot;oldT=&#123;&#125; newT=&#123;&#125; Temperature changed.&quot;, newT, oldT);`</span><br><br>### 五、日志规约（《阿里代码规约》）<br><br>#### <span class="hljs-number">1</span>.【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架 SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。<br><br>#### <span class="hljs-number">2</span>.【强制】在日志输出时，字符串变量之间的拼接使用占位符的方式。<br><br>*说明*：因为String字符串的拼接会使用StringBuilder的append()方式，有一定的性能损耗。使用占位符仅是替换动作，可以有效提升性能。<br><br>*正例*：`logger.debug(<span class="hljs-string">&quot;Processing trade with id: &#123;&#125; and symbol: &#123;&#125;&quot;</span>, id, symbol)<span class="hljs-comment">;`</span><br><br>#### <span class="hljs-number">3</span>.【强制】对于trace/debug/info级别的日志输出，必须进行日志级别的开关判断。<br><br>说明：虽然在debug(参数)的方法体内第一行代码isDisabled(Level.DEBUG_INT)为真时（Slf4j的常见实现Log4j和Logback），就直接<span class="hljs-keyword">return</span>，但是参数可能会进行字符串拼接运算。此外，如果debug(getName())这种参数内有getName()方法调用，无谓浪费方法调用的开销。<br><br>&gt; 如果参数内有方法调用或者字符串拼接，则必须进行日志级别的开关判断，否则不需要强求<br><br>*正例*：<br><br>```java<br>// 如果判断为真，那么可以输出trace和debug级别的日志 <br>if (logger.isDebugEnabled()) &#123;<br>    logger.debug(<span class="hljs-string">&quot;Current ID is: &#123;&#125; and name is: &#123;&#125;&quot;</span>, id, getName())<span class="hljs-comment">; </span><br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="4-【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字throws往上抛出。"><a href="#4-【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字throws往上抛出。" class="headerlink" title="4. 【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字throws往上抛出。"></a>4. 【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字throws往上抛出。</h4><p><em>正例</em>：<code>logger.error(param.toString() + &quot;_&quot; + e.getMessage(), e);</code></p><h4 id="5-【推荐】谨慎地记录日志。生产环境禁止输出debug日志；有选择地输出info日志；如果使用warn来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。"><a href="#5-【推荐】谨慎地记录日志。生产环境禁止输出debug日志；有选择地输出info日志；如果使用warn来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。" class="headerlink" title="5.【推荐】谨慎地记录日志。生产环境禁止输出debug日志；有选择地输出info日志；如果使用warn来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。"></a>5.【推荐】谨慎地记录日志。生产环境禁止输出debug日志；有选择地输出info日志；如果使用warn来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。</h4><p> 说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？</p><h4 id="6-【推荐】可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出error级别，避免频繁报警。"><a href="#6-【推荐】可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出error级别，避免频繁报警。" class="headerlink" title="6.【推荐】可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出error级别，避免频繁报警。"></a>6.【推荐】可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出error级别，避免频繁报警。</h4><p> 说明：注意日志输出的级别，error级别只记录系统逻辑出错、异常或者重要的错误信息。</p><h3 id="六、后记"><a href="#六、后记" class="headerlink" title="六、后记"></a>六、后记</h3><p>规则终究是死的，记日志的时候需要结合具体场景多做思考，在哪里记日志能帮助后续排查问题？哪里的日志又是重复记录乃至无效日志？结合异常处理来看，哪些异常应该抛给上层调用方，根据上层应用不同场景选择不同的处理方式；哪些异常应该就地给解决了，处理异常的时候一定要记录一下异常信息。</p><h2 id="附：参考链接-文档"><a href="#附：参考链接-文档" class="headerlink" title="附：参考链接&amp;文档"></a>附：参考链接&amp;文档</h2><ol><li><a href="http://sonar.thunisoft.com/coding_rules?activation=true&open=java:S106&q=Stand&qprofile=java-aatp-checks-93565">Standard outputs should not be used directly to log anything</a></li><li><a href="https://zhuanlan.zhihu.com/p/24272450">Java 日志框架解析(上) - 历史演进</a></li><li><a href="https://mp.weixin.qq.com/s/8VvBdRH_Yc-Dt4HFGbC5rg">架构师必备，带你弄清混乱的JAVA日志体系！</a></li><li><a href="https://time.geekbang.org/column/article/220307">13 | 日志：日志记录真没你想象的那么简单</a></li><li><a href="http://www.logback.cn/">logback中文手册</a></li><li><a href="http://www.slf4j.org/manual.html">SLF4J user manual</a></li><li>《阿里代码规约》</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins在Java web项目CI/CD中的简单应用</title>
    <link href="/2023/03/02/Jenkins%E5%9C%A8JavaWeb%E9%A1%B9%E7%9B%AECICD%E4%B8%AD%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
    <url>/2023/03/02/Jenkins%E5%9C%A8JavaWeb%E9%A1%B9%E7%9B%AECICD%E4%B8%AD%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://mp.weixin.qq.com/s/-bJfhCfjlKZ3gK2uf2w3Ug">傲然绝唳的小栈</a></p></blockquote><h1 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h1><blockquote><p>Jenkins is a self-contained, open source automation server which can be used to automate all sorts of tasks related to building, testing, and delivering or deploying software.</p></blockquote><ul><li>主要介绍使用Jenkins来达到持续集成持续交付&#x2F;持续部署（CICD）的一些方案和选择，不涉及Jenkins的深入研究。</li><li>实现CI&#x2F;CD的方式有很多种，本文介绍的只是我这几天一些粗略的摸索，仅供大家参考。</li></ul><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><ul><li>Jenkins的安装方式有很多选择，这里不做详细讨论，我这次采用了比较熟悉的部署WAR包的方式，将其部署到tomcat上来运行。<br><img src="/../resources/jenkins/1.image" alt="图片"></li><li>部署完成之后访问相应地址即可，这是会提示新建用户，大家按照指引一步一步完成即可，不做赘述。</li></ul><h2 id="二、新建任务"><a href="#二、新建任务" class="headerlink" title="二、新建任务"></a>二、新建任务</h2><ul><li><p>Jenkins部署完成之后，接下来便要进入正题了，新建一项任务，已达到CICD的目的。</p></li><li><p>首页左侧菜单按选择新建任务-》输入任务名称-》构建一个自由风格的软件项目-》确定（这里我已经创建过一个名为test的项目了）<br><img src="/../resources/jenkins/2.image" alt="图片"><br><img src="/../resources/jenkins/3.image" alt="图片"></p></li><li><p>点击确定后进入了该项目的配置页面，先总览所有的配置项，共有六项：General，源码管理，构建触发器，构建环境，构建，构建后操作.从字面意思上不难理解。</p><ul><li>General，一些通用的信息，本次不做重点；</li><li>源码管理，构建的来源，git，svn，亦或是其他一些源码管理服务；</li><li>构建触发器，以何种规则自动触发源码的构建（持续构建），若该项不做任何配置，则只能手动触发；</li><li>构建环境，本次也未做关键性修改；</li><li>构建，以何种方式构建，maven， gradle， 亦或是其他；</li><li>构建后操作，成功构建之后的一些操作，持续交付&#x2F;持续部署的操作主要放到这一块。<br><img src="/../resources/jenkins/4.image" alt="图片"></li></ul></li></ul><p>接下来分别较少这几项配置，以及用到的插件，已完成CI&#x2F;CD的目标。</p><h3 id="1-General"><a href="#1-General" class="headerlink" title="1. General"></a>1. General</h3><ul><li>本次并没有做一些关键的修改<br><img src="/../resources/jenkins/5.image" alt="图片"></li></ul><h3 id="2-源码管理"><a href="#2-源码管理" class="headerlink" title="2. 源码管理"></a>2. 源码管理</h3><ul><li><p>只说明git的一些相关配置，其他的源码管理服务同理<br><img src="/../resources/jenkins/6.image" alt="图片"></p></li><li><p>Repository URL： git上的源码地址</p></li><li><p>Credentials： 用户名&#x2F;密码</p></li><li><p>Branch Specifier：指定需要构建的分支</p></li><li><p>上边这些做完后其实基本上已经可以了，之所以修改Advanced clone behaiours，是防止第一次构建时拉取源码超时，默认超时时间为10minutes，多次构建失败后，我把此处修改为了20minutes，如果依旧超时，可延长此处时间，或检查网络（点击Additional Behaviours旁边的add，选择Advanced clone behaiours）</p><ul><li>Shallow clone，Shallow clone depth：浅拷贝，节省拷贝时间和磁盘空间</li></ul></li></ul><h3 id="3-构建触发器"><a href="#3-构建触发器" class="headerlink" title="3. 构建触发器"></a>3. 构建触发器</h3><ul><li>实现触发构建的方式主要有定时触发、web hook触发，这些触发方式可以单独使用，也可以组合使用。</li></ul><h4 id="3-1-定时触发"><a href="#3-1-定时触发" class="headerlink" title="3.1 定时触发"></a>3.1 定时触发</h4><ul><li><p>Build periodically： 周期性构建</p></li><li><p>Poll SCM： 周期性检测，若源码有变化则构建</p></li><li><p>图中为每六小时检测一次</p><ul><li><a href="http://heipark.iteye.com/blog/1736477">搞清楚jenkins中“Poll SCM”和“Build periodically”的啥意思</a><br><img src="/../resources/jenkins/7.image" alt="图片"></li></ul></li><li><p>定时构建部署，可控制频率</p></li></ul><h4 id="3-2-Gitlab-Hook插件"><a href="#3-2-Gitlab-Hook插件" class="headerlink" title="3.2 Gitlab Hook插件"></a>3.2 Gitlab Hook插件</h4><p> 　　web hook触发主要介绍gitlab hook插件，接下来我们先保存已经完成的配置，回到首页，下载所需插件。<br><img src="/../resources/jenkins/8.image" alt="图片"></p><p>　　可选插件中搜索gitlab，勾选列表中的GitLab Plugin和Gitlab Hook Plugin, 选择直接安装。待安装完成后回到首页，点击右边刚刚我们创建的任务，然后点击配置回到我们之前的配置页面。<br><img src="/../resources/jenkins/9.image" alt="图片"></p><p>　　此时发现构建触发器中多了个选项：<code>Build when a change is pushed to GitLab. GitLab CI Service URL: http://172.16.192.142:9081/jenkins/project/test</code>，如果仍然没有，尝试重启Jenkins之后查看。<br><img src="/../resources/jenkins/10.image" alt="图片"></p><p>　　图中红框上边为Gitlab Web Hook处需要添加的URL，若Jenkins设置了不允许匿名用户执行构建操作，则需要在Gitlab安全令牌处添加第二个红圈处的Secret token。</p><ul><li>Gitlab处需要增加的配置（设置-》集成，注意登录账户需要有相应权限）<br><img src="/../resources/jenkins/11.image" alt="图片"></li><li>随时提交，随时构建，快速相应开发人员的操作，但需要开发人员提交代码的时候确保提交可用，多次commit一次push，除非紧急需要尽量在午休时间，早上上班前，晚上下班后push代码</li><li>参考资料:<a href="https://www.cnblogs.com/kevingrace/p/6479813.html">Gitlab利用Webhook实现Push代码后的jenkins自动构建</a></li></ul><h3 id="4-构建环境"><a href="#4-构建环境" class="headerlink" title="4. 构建环境"></a>4. 构建环境</h3><ul><li>没有关键配置的修改，其中Color ANSI Console Output为下载的插件AnsiColor，可以使日志输出带有颜色，详情可查看<a href="https://zhuanlan.zhihu.com/p/22032462?refer=debugtalk">Jenkins 的输出日志也可以变得色色的</a></li></ul><h3 id="5-构建"><a href="#5-构建" class="headerlink" title="5. 构建"></a>5. 构建</h3><ul><li>构建部分主要采用了maven构建，确保部署Jenkins的机器已经配置好了maven环境，maven的配置不做赘述。<br><img src="/../resources/jenkins/12.image" alt="图片"></li></ul><h3 id="6-构建后操作"><a href="#6-构建后操作" class="headerlink" title="6. 构建后操作"></a>6. 构建后操作</h3><ul><li>使用maven构建打包完成后，与pom.xml同级的target目录下会生成一个war包(取决于pom.xml中的配置，对pom.xml的配置不做描述)，接下来我们要做的就是将生成的war包部署到中间件或容器中，下面主要介绍两个插件，可以根据实际情况有选择的使用，使用之前首先需要参考之前介绍的步骤下载相应插件。</li></ul><h4 id="6-1-Deploy-to-Container插件"><a href="#6-1-Deploy-to-Container插件" class="headerlink" title="6.1 Deploy to Container插件"></a>6.1 Deploy to Container插件</h4><ul><li>达到效果：构建前需保证目标中间件正常启动，每次Jenkins构建时会把指定的war包自动部署到指定的服务器上的context path中，如果目标服务已存在，首先undeploy目标服务，再把新的war包redeloy上去，已完成自动部署的功能。</li><li>仅支持GlassFish,JBoss,Tomcat<br><img src="/../resources/jenkins/13.image" alt="图片"></li></ul><ol><li><p>增加构建后操作步骤中选择Deploy war&#x2F;ear to a container</p></li><li><p>WAR&#x2F;EAR files中填上所需要部署的程序包，支持 <code>**/*.war</code>的形式</p></li><li><p>Context path配置程序相对于中间件环境的发布路径</p></li><li><p>本文中Containers我选择了Tomcat 7.x，Credentials需要在tomcat里配置上，Tomcat URL即环境的基础地址</p><ul><li>在tomcat中添加授权用户：修改conf&#x2F;tomcat-users.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">&quot;manager-script&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">username</span>=<span class="hljs-string">&quot;caozeal&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;******&quot;</span> <span class="hljs-attr">roles</span>=<span class="hljs-string">&quot;manager-script&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/../resources/jenkins/14.image" alt="图片"></p></li><li><p>只是做上边这些配置的话，你会发现Jenkins的自动部署仅支持第一次，已有旧版应用运行时，自动部署会报undeploy失败，原因是在应用运行时，tomcat会对应用的资源进行锁定，导致无法覆盖更新，这时需修改tomcat的另一项配置：conf&#x2F;context.xml（详情可查看<a href="https://blog.csdn.net/yanjun008/article/details/41249753">Tomcat中antiResourceLocking和antiJARLocking的作用</a>）</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">antiJARLocking</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">antiResourceLocking</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/../resources/jenkins/15.image" alt="图片"></p><h4 id="6-2-Publish-Over-SSH插件"><a href="#6-2-Publish-Over-SSH插件" class="headerlink" title="6.2 Publish Over SSH插件"></a>6.2 Publish Over SSH插件</h4><ul><li><p>通过SSH操作目标服务，从而传输文件，执行命令已达到目的</p></li><li><p>更灵活，支持各种中间件服务器</p></li><li><p>首先在系统设置中配置上所需连接的远程服务器，配置上相关配置，其中Remote Directory是访问服务器的基础路径，之后步骤能用到<br><img src="/../resources/jenkins/16.image" alt="图片"></p></li><li><p>然后回到任务配置继续配置构建后操作一块<br><img src="/../resources/jenkins/17.image" alt="图片"></p></li><li><p>Remote directory远程服务器文件夹，空即为默认的上边步骤配置的路径，如果此处不为空，即为相对路径</p></li><li><p>Remove prefix 去除前置路径</p></li><li><p>Exec command 执行脚本，此处的脚本比较简单，调用目标中间件的停止与启动</p></li><li><p>需要注意的是执行脚本的时候有个坑，读取不到系统的环境变量，原因是此处执行脚本的方式为non-interactive + non-login shell，不会读取&#x2F;etc&#x2F;profile中的配置，此处的解决方案是采用bash执行命令，由于bash恒执行BASH_ENV中的变量，因此需要把&#x2F;etc&#x2F;profie赋值到BASH_ENV中，详细解决思路参考链接</p><ul><li><a href="https://www.cnblogs.com/asia90li/p/6437677.html">ssh连接远程主机执行脚本的环境变量问题</a></li><li><a href="https://www.cnblogs.com/hopeworld/archive/2011/03/29/1998488.html">转：深入了解bash与sh的区别</a></li></ul></li></ul><h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h2><ul><li>至此已经完成了从开发人员push代码到应用构建、部署等相关操作的基本自动流程，具体细节部分还需要继续深入研究探索</li><li>遗留问题：<ul><li>Jenkins构建的时候控制台乱码<ul><li>参考<a href="https://www.cnblogs.com/dtest/p/4142825.html">Jenkins控制台中文输出乱码解决方法</a>处理</li><li>解决之后，Jenkins启动的tomcat发生乱码</li></ul></li><li>自动构建部署的时候，Jenkins调用命令启动StartTAS.sh的时候会一直监听启动日志，直到超时才断开链接，这时候因超时而导致本次构建为黄灯，即不稳定的构建</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/03/02/hello-world/"/>
    <url>/2023/03/02/hello-world/</url>
    
    <content type="html"><![CDATA[<blockquote><p>傲然擢清骨，绝世唳天门。</p></blockquote><h2 id="这是首篇"><a href="#这是首篇" class="headerlink" title="这是首篇"></a>这是首篇</h2><p> <a href="https://emojipedia.org/grinning-squinting-face/">😆</a>没有什么意义，仅仅是创建好之后，总得先有点东西做个标记，就像数组的index 0，之后就往后慢慢添加。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
